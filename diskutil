#!/bin/bash


# use shake to defrag


#defrag  app = shake
#fsck /dev/sda1

SCRIPTNAME="${0##*/}"
PRODUCTNAME=$SCRIPTNAME
VER="0.1.6"  #2022-11-08
BACKTITLE="Disk Utility"

ROOT_DEV=$(findmnt -no source /)


SETTINGS="/home/$USER/.config/$SCRIPTNAME/$SCRIPTNAME.conf"
LOG_FILE="/home/$USER/.config/$SCRIPTNAME/$SCRIPTNAME.log"
LOG=on

FILESYSTEMS="fat16 fat32 exfat ntfs ext2 ext3 ext4 linux-swap"

WHITE='\033[1;37m'
RED='\033[1;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
LTBLUE='\033[1;34m'

NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }
echo_green()        { (echo -e "${GREEN}$*${NC}") }
echo_blue()         { (echo -e "${LTBLUE}$*${NC}") }    

ERRORS=0
INTERFACE=cli

BUFFER=$((10*1024*1024))  # 10 meg




disk_utility_help(){
echo "Disk Utility Tool
Utility to manage disks and partitions. Based on Apple's diskutil
Most commands DO NOT require an administrator or root user
WARNING: Most destructive operations are not prompted

This simplifies the use of: parted, lsblk, udisksctl mount, udisksctl unmount, udisksctl power-off, etc.

Usage:  diskutil [quiet] <verb> <options>, where <verb> is as follows:

     list                 (List available disks and partitions)
     info[rmation]        (Get information on a specific disk or partition)
     listFilesystems      (List file systems available for formatting)

     u[n]mount            (Unmount a single filesystem)
     unmountDisk          (Unmount an entire disk (all filesystems))
     eject                (Eject a disk)
     mount                (Mount a single filesystem)
     mountDisk            (Mount an entire disk (all mountable filesystems))

     rename[Filesystem]   (Rename a filesystem)

     verify               (Verify the data structures of a filesystem)
     repair               (Repair the data structures of a filesystem)
     verifyDisk           (Verify the components of a partition map of a disk)
     repairDisk           (Repair the components of a partition map of a disk)
     resizePartition      (Resize a partition and filesystem, increasing or decreasing its size)
     resizeFilesystem

  --  DESTRUCTIVE OPERATIONS ---
  
     erasePartition       (Erase an existing partition, removing all data in the partition)
     eraseDisk            (Erase an existing disk, removing all partitions and data)
     reformat             (Erase an existing partition with same name and filesystem)
     X eraseOptical         (Erase optical media (CD/RW, DVD/RW, etc.))
     
     zeroDisk             (Erase a disk, writing zeros to the media)
     randomDisk           (Erase a disk, writing random data to the media)
     secureErase          (Securely erase a disk)

     createPartitionTable  (Erase a disk's partition table and create a new one)
     X partitionDisk        ((re)Partition a disk, removing all volumes)
     addPartition         (Create a new partition to occupy free space)
     delPartition         (Delete a partition)

     hexedit              (edit disk or partition)

diskutil <verb> with no options will provide help on that verb
"
}


run_command(){
    local CMD=$1
    local LINE=$2
    local QUIET=${3:-n}
    
    echo -n "- Running: "
    ui_echo "$CMD" blue
    eval $CMD
    RC=$?
    if (( $RC )); then
        #ui_msg_error $LINENO "Error $RC running '$CMD'"
        ui_echo "~ Exit_status $RC running '$CMD'" red log
        return $RC
    fi
}


file_path(){
    dirname "$*"
}

function info() {
	echo "$SCRIPTNAME: $1 ..."
}


function error() {
	echo -n "$SCRIPTNAME: ERROR occured in line $1: "
	shift
	echo_red "$@"
}


env_installer(){
    local INSTALLER=

    if [ -f /usr/bin/apt ]; then             # debian
        INSTALLER="apt install -y"
    elif [ -f /usr/bin/pacman ]; then        # arch
        INSTALLER="pacman -S --noconfirm"
    elif [ -f /usr/bin/dnf ]; then            #rpm / fedora
        INSTALLER="dnf install -y"  
    fi

    echo "$INSTALLER"
}


env_install_tools() {   
    TOOL_MISSING=false
    TOOLS=$(parted )
    INSTALL=$(env_installer)
    
    for TOOL in $TOOLS ; do
        #if [ ! $(which $TOOL) ]; then
        if [ ! -f /usr/bin/$TOOL ]  && [ ! -f /usr/local/bin/$TOOL ] ; then
            TOOL_MISSING=true
        fi
    done
    
    if [ $TOOL_MISSING = "true" ]; then
        echo "Installing required tools ($REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL)"
        RESULT=y
        if [ $RESULT != "y" ]; then
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
            return 1
        fi

        for TOOL in $REQUIRED_TOOLS ; do
             if [ ! -f /usr/bin/$TOOL ]; then
                echo_white Installing $TOOL ...
                sudo $INSTALL $TOOL
                EXIT_CODE=$?
                if [ $EXIT_CODE != 0 ]; then
                    ui_msg "Error" "$TOOL not installed." "red"
                fi
            fi
        done
        
        # Special installs ...
        
        # Install PiShrink
        if [ ! -f /usr/local/bin/pishrink.sh ]; then
            echo_white Installing pishrink...
            wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
            sudo chmod +x pishrink.sh
            sudo mv pishrink.sh /usr/local/bin
            if [ ! -f /usr/local/bin/pishrink.sh ] ; then
              ui_msg "Error" "pishrink not installed." "red" 
            else
              ui_msg  pishrink installed.
            fi
        fi

        # Install xz
        if [ ! -f /usr/bin/xz ]; then
            echo_white Installing xz-utils...
            sudo $INSTALL xz-utils
            if [ ! -f /usr/bin/xz ]; then
               ui_msg "Error" "xz not installed." "red" 
            fi
        fi
    
    fi
}    


env_install_smarttools(){
    # https://www.addictivetips.com/ubuntu-linux-tips/check-hard-drive-health-on-linux/
    
#Ubuntu
sudo apt install smartmontools
#Debian
sudo apt-get install smartmontools
#Arch Linux
sudo pacman -S smartmontools
#Fedora
sudo dnf install smartmontools
#OpenSUSE
sudo zypper install smartmontools
    
}


# ---------- Misc functions

do_beep(){
    FREQ=${1:-600}
    TIME=${2:-.5}
    
    if [[ $SOUND = on ]] ; then
        (speaker-test -t sign -f $FREQ > /dev/null & sleep $TIME && kill -9 $! ) > /dev/null
      #  sleep .5  # to allow the beep to end
    fi
}


do_beep_up(){
    do_beep 500 .3
    do_beep 600 .6
}


do_beep_down(){
   do_beep 600 .3
   do_beep 500 .6
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


do_countdown(){  
    local MAX=${1:-10}
    local MSG=${2:-"Pausing for $MAX seconds... Press y to continue immediately or any other key to stop"}
 
   # echo "Pausing for $MAX seconds... Press y to continue immediately or any other key to stop"
    echo "$MSG"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
        read -s -t 1 -N 1 INPUT
        if [[ ! -z $INPUT ]]; then
            if [[ $INPUT = y ]]; then
                echo Continuing...
                return
            else
                echo " $INPUT Stopping countdown..."
                return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
    echo ...
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
    
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}



env_root_device() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    # new simpler way
    #ROOT_PARTITION=$(findmnt -no source /)
    #ROOT_MAJ=$(findmnt  -n -e  -o MAJ:MIN / | cut -d: -f1)
    #ROOT_DEV=$(lsblk | grep $ROOT_MAJ:0 | cut -d" " -f1)
    #echo $ROOT_DEV
    
    
    # simpler
    findmnt -no source /
}

 
env_which () {
    #fixes manjaro's which command 
    local FILE=$1
    
    # if which not installed, try to install it
    which which 1>/dev/null 2>/dev/null
    if (( $? )); then
        sudo apt install which -y
        sudo pacman -S which --noconfirm
        sudo dnf install which -y
    fi
    
    which $FILE 1>/dev/null 2>/dev/null
    if (( $? )); then
        #echo false
        return 1
    else
        echo 1
        return 0
    fi       
}


is_number(){
    NUM=$1
    
    # trim NUM
    NUM=$(echo $NUM | sed 's/ //g')
    
    case $NUM in
        ''|*[!0-9]*) 
            echo false
            return 1
            ;;
        *) 
            echo true
            return 0
            ;;
    esac
}


info_validate_num(){
    local VAR=$1
    local NUM=$2
   # local LINE=$3
    local MIN=$3
    local MAX=$4

   
    if ! $(is_number "$NUM"); then 
        ((ERRORS++))
        error $LINENO "Variable '$VAR' '$NUM' not a number"
        return 1
    fi
    
 
    if (( $MIN )); then
        if [ "$NUM" -lt "$MIN" ]; then
            ((ERRORS++))
            error $LINENO "Variable '$VAR' '$NUM' ($(bytes $NUM) too small ('$MIN' '$MAX')"
        fi
    fi
    
    
    if (( $MAX )); then
        if [ $NUM -gt $MAX ]; then
            ((ERRORS++))
            error $LINENO "Variable '$VAR' '$NUM' too big"
        fi
    fi
}


info_validate(){
    echo_white Validating data...
    
    # info_validate_num variable num min max
    
    #echo Errors start=$ERRORS
    local DEVICE_MIN=$((10*1025*1024))          # 10mb
    local DEVICE_MAX=$((1024*1024*1024*1024))   # 1TB
    local PART_MIN=$((10*1024*1024))
    
    
    # confirm we got good partition numgers
    info_validate_num PARTNUM $PARTNUM 1 20
    info_validate_num DEVICE_SIZE $DEVICE_SIZE $DEVICE_MIN $DEVICE_MAX
    info_validate_num BUFFER $BUFFER
    
    info_validate_num PART_START $PART_START 512 $DEVICE_MAX
    info_validate_num PART_END $PART_END $PART_START $DEVICE_MAX
    info_validate_num PART_SIZE $PART_SIZE $PART_MIN $DEVICE_MAX
    info_validate_num PART_MAX $PART_MAX  $PART_MIN $DEVICE_MAX 
    
    # confirm we got good filesystem numgers
    info_validate_num FS_SIZE $FS_SIZE $(( $PART_SIZE-$((5*1024*1024)) ))  $PART_SIZE
    info_validate_num FS_MIN $FS_MIN $PART_MIN $PART_SIZE
    
    info_validate_num MIN_SIZE $MIN_SIZE
    info_validate_num MIN_END $MIN_END
    info_validate_num MAX_SIZE $MAX_SIZE
    info_validate_num MAX_END $MAX_END
    
    
    if $(is_number "$SIZE"); then
        #echo validateing size
        info_validate_num SIZE $SIZE $MIN_SIZE $MAX_SIZE
    fi
    
     
    if (( $ERRORS )); then
        error $LINENO "$ERRORS Errors found in validating data. Recommend running '$SCRIPTNAME $PARTITION fix'."
        return 1
    else
        echo_green info_validate OK
    fi    
    
}


bytes(){
    # translates from bytes to human readable and vice-verse
    # currently shows 3 significant digits.
    local BYTES=$1
    local OUTPUT=${2:-"-h"};  #human or bytes
    
    local BASE=$(echo $BYTES | tr -cd '[[:digit:]]' )
    local SUFFIX=$(echo $BYTES | tr -cd '[[kmgtbKMGTB]]' )

    if ! $(is_number $BASE); then
        return 1
    fi

    # if no translation needed... then just echo the input and leave
    if [ $OUTPUT != "-h" ] && [ -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi
    
     if [ $OUTPUT = "-h" ] && [ ! -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi



    if [ $OUTPUT = "-h" ] ; then  # translate to human readable
    
        if [ -z $SUFFIX ]; then
            local LEN=${#BYTES}
            local k_ilo=1024;
            local m_ega=$k_ilo*$k_ilo;
            local g_iga=$m_ega*$k_ilo;
            local t_era=$g_iga*$k_ilo;
            local p_eta=$t_era*$k_ilo;
            
            [ -z "$BYTES" ] && return
            
            NUM='^[0-9]+$'
            if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number   
                return 1
            fi
            
            case $LEN in
                4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
                5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
                6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
                
                7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
                8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
                9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
                
                10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
                11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
                12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
                
                13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
                14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
                15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
                *)  echo $BYTES ;;
            esac
        else
            echo $BYTES
        fi    

    else  # translate to bytes
    
        case $SUFFIX in
            b|B|"")         echo $BASE            ;;
            k|K|kb|KB)      echo $(($BASE*1024))   ;;
            m|M|mb|MB)      echo $(($BASE*1024*1024))   ;;
            g|G|gb|GB)      echo $(($BASE*1024*1024*1024))      ;;
            t|T|tb|TB)      echo $(($BASE*1024*1024*1024*2014))  ;;
            *)              error Error $LINENO            ;;
        esac
    fi
}


########################################################################
# UI functions
########################################################################

ui_countdown(){
    local SECONDS=${1:-10}
    local TITLE="${2:-Countdown}"
    #local MESSAGE="${3:-Counting down...}"
    local MESSAGE=${3:-"Pausing for $SECONDS seconds... Press y to continue immediately or any other key to stop"}
    
    if [[ $INTERFACE = cli ]]; then
        do_countdown $SECONDS "$MESSAGE"
    else
        whiptail_countdown "$SECONDS" "$TITLE" "$MESSAGE"
    fi
}


ui_echo(){
    # used to notify on the terminal what is going on.  optionally log it.
    # ui_echo "msg" red log
    MSG="$1"
    COLOR="${2:-grey}"
    local LOGIT="${3:-log}"   # or nolog
    
    if [[ $LOGIT = log ]]; then    
        ui_log "$MSG"  
    fi
    
    case $COLOR in
        red)        echo_red "$MSG" ;;
        white)      echo_white "$MSG" ;;
        blue)       echo_blue "$MSG" ;;
        green)      echo_green "$MSG" ;;
        *)          echo -e "$MSG" ;;
    esac
}


ui_log(){
    # usage ui_log "message"
    INFO=$*
    
    INFO=$(echo $INFO | sed 's/\\n/ -/g')  #change newline for ~
    
    if [[ ! -d $(file_path $LOG_FILE) ]]; then
        mkdir -p $(file_path $LOG_FILE)
    fi
    
    if [[ $LOG = on ]]; then
        touch $LOG_FILE
        echo "$(date "+%Y-%m-%d %H:%M") $INFO" >> $LOG_FILE
    fi
}


ui_msg() {
    #general message function.  Supports CLI whiptail and logging.
    # usage ui_msg INSTALL "$MSG" white OK log
    TITLE="$1"
    MSG="${2:-no message}"
    COLOR="${3:-grey}"
   # OK_BUTTON="${4:-Back}"
    OK_BUTTON="${4:-OK}"
    local LOGIT="${5:-no}"   # or log
    
    if [[ $LOGIT = log ]]; then
        ui_log "$MSG"
    fi    
    
    if [[ $INTERFACE = cli ]]; then
        ui_echo "$TITLE: $MSG" $COLOR nolog 
    else
        whiptail --backtitle "$BACKTITLE" --title "$TITLE" --scrolltext --ok-button "$OK_BUTTON" --msgbox "$MSG" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
    fi
}


ui_msg_error() {
    # usage:  ui_msg_error $LINENO "message"
    LINE=$1
    shift
    do_beep_down
    MSG="$@"
    ui_msg ERROR "~ Error at line $LINE. $MSG" red "" log
}


ui_msg_warning(){
    # usage:  ui_msg_warning $LINENO "message"
    LINE=$1
    shift
    do_beep
    do_beep
    MSG="$@"
    ui_msg WARNING "~ $MSG" red "" nolog
}


ui_yesno(){
    # general yes/no function.  Supports CLI and whiptail.
    # note, this output is often assigned to a variable, so don't add any additional echo statements.
    TITLE="$1"
    MSG="$2"
    DEFAULT="${3:-""}"   # defaults to Yes.  can specify --defaultno
   # COLOR="${4:-white}"  color does not work with the 'read' command
    
    if [[ $INTERFACE = cli ]]; then
        MSG="$PRODUCTNAME: $TITLE: $MSG  [y/n]?"
        # change 'newline' chars to ' -'
        MSG=$(echo $MSG | sed 's/\\n/ -/g')
        while true; do        
            read -s -n1 -p "$MSG" yn
            case $yn in
                [Yy]* ) echo y; return 0;;
                [Nn]* ) echo n; return 0;;
                * )     ;;
            esac
        done
    else    
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" $DEFAULT --yesno "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH 3>&1 1>&2 2>&3
        RC=$?
        if (( $RC )); then
            echo n
        else
            echo y
        fi
        return $RC
    fi
}





########################################################################
########################################################################
# low level functions
2_low_level_functions(){  
    x=1 ; }
########################################################################


########################################################################
# device low level functions
########################################################################


media_device_fullname(){
    # returns devicename with /dev/ added if needed
    local DEVICE=$1
    
    # add /dev/ if missing
    if [[ ${DEVICE:0:5} != "/dev/" ]]; then    # "Device prefix not specified.  Adding '/dev/'"
        echo "/dev/$DEVICE"
    else
        echo "$DEVICE"
    fi
}


media_device_partname(){
    # returns the partition name if present.  Same as returns the last digits in the string.   
    local PARTNUM=$(echo $1 | sed 's/.*[^1-9]\(.*\)$/\1/')
    
    if [ -z "$(echo $1 | grep p)" ] ;then
        echo $PARTNUM
    else
        echo p$PARTNUM
    fi
}


media_device_partnum(){
    # returns the partition number if present.  Same as returns the last digits in the string.
    #echo $1 | sed 's/.*[^1-9]\(.*\)$/\1/'
    
    local PARTNUM=$(echo $1 | sed 's/.*[^1-9]\(.*\)$/\1/')
    
    echo $PARTNUM
}


media_device_size(){
    local DEVICE=$(media_device_name $1)
    #sudo parted -ms "$DEVICE" unit B print | grep $DEVICE | cut -d ':' -f 2 | tr -d 'B'
    lsblk $DEVICE -b -n -d -o size 
}


media_device_type(){
    local DEVICE=$(media_device_fullname $1) 
    lsblk $DEVICE -n -d -o TYPE
}


media_device_name(){
    # returns a clean devicename
    
    if [[ -z $1 ]]; then
        return
    fi
    
    # add /dev/ to the front if missing
    local DEVICE=$(media_device_fullname $1)
    
    # remove the partition number from then end
    if [ -z "$(echo $DEVICE | grep p)" ] ;then
        echo $DEVICE | sed 's/[1-9]*//g'
    else
        echo $DEVICE | sed 's/p[1-9]*//g'
    fi
}


media_device_partition_table(){
    #local DEVICE=$(media_device_name $1)
    #echo $(sudo parted -m $DEVICE print | grep $DEVICE | cut -d: -f6)
    
    local PARTITION=$(media_device_fullname $1)
    lsblk $PARTITION -n -o PTTYPE
}


media_device_checktarget(){
    local TARGET=$(media_device_fullname $1)
    local TYPE=$2    # disk or part

    
    if [[ -z $TARGET ]]; then
        echo "Target '$TARGET' is blank"
        return 1
    fi
    
    if [[ ! -e $TARGET ]]; then
        echo "Target '$TARGET' does not exist"
        return 1
    fi

    
    if  [[ $(media_device_type $TARGET) != $TYPE ]]; then
        echo "Target '$TARGET' is not type '$TYPE'"
        return 1  
    fi        
}

# -------------------------------------------------------------------------------
# media_filesystem low-level functions
# -------------------------------------------------------------------------------

media_filesystem_fs_type(){
    local PARTITION=$(media_device_fullname $1)
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)   
    local FS_TYPE
   
   # works with fat32, but not exfat
   FS_TYPE=$(sudo parted $DEVICE -m print | grep ^$PARTNUM: | cut -d: -f5)
   
   # works with exfat
   if [[ -z $FS_TYPE ]]; then
        FS_TYPE=$(lsblk -n $PARTITION -o FSTYPE)
   fi
   
   echo $FS_TYPE
   
   return
   
   
   
   # using lsblk is faster, but unreiable with dos partition tables...
    local FS_TYPE=$(lsblk -n $PARTITION -o FSTYPE)
    if [[ $FS_TYPE == "vfat" ]]; then
        FS_TYPE=$(lsblk -n $PARTITION -o FSVER)
    fi
    
    if [[ -z $FS_TYPE ]]; then
        echo_red ERROR in FS_TYPE '$FS_TYPE' $LINENO
        exit
    fi
    
    if [[ $FS_TYPE = "lsblk: unknown column: FSVER" ]]; then
        FS_VER=$(sudo parted $DEVICE -m print | grep ^$PARTNUM: | cut -d: -f5)
    fi

    echo ${FS_TYPE,,}   # this makes it lower case
    
  #  local FS_TYPE=$(sudo parted $DEVICE -m print | grep ^$PARTNUM: | cut -d: -f5)
    
    # dumb bandaid
 #   if [[ -z $FS_TYPE ]]; then
 #       FS_TYPE=exfat
 #   fi
    
    
    
}


media_filesystem_ismounted(){
    local PARTITION=$(media_device_fullname $1)
    local ROOT_DEV=$(findmnt -no source /)
    
    if [[ $PARTITION == $ROOT_DEV ]]; then
        echo true
        return
    fi
    
    
    if [[ -z $(df | grep ^$PARTITION) ]]; then
        # not mounted
        return 
    else
        # it is mounted
        echo true
        return 
    fi
}


#echo_blue test
#echo "sda1 is mounted=$(media_filesystem_ismounted /dev/sda1)"
##echo "MMC is mounted=$(media_filesystem_ismounted /dev/mmcblk0p1)"
#echo_blue test done
#exit


media_filesystem_min(){  
    local PARTITION=$(media_device_fullname $1)
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)
    local FS_MIN
    local blocksize
    local minsize
     
     case $FS_TYPE in
     
        fat16|fat32)
           FS_MIN=$(sudo fatresize -i "$PARTITION" | grep Min | cut -d : -f2 | sed 's/ //g')
            ;;
             
        exfat)
            FS_MIN=$(sudo fsck.exfat  "$PARTITION" | grep Used | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
            ;;     
            
        ntfs)
            #sudo ntfsfix -d $PARTITION
            FS_MIN=$(sudo ntfsresize -i "$PARTITION" | grep "resize at" | cut -d t -f 3 | cut -d b -f1 | sed 's/ //g') 
            if ! (( $FS_MIN )); then
                FS_MIN=$(media_filesystem_size $PARTITION)
            fi
            ;; 
     
        ext2|ext3|ext4)       
            blocksize="$(sudo tune2fs -l "$PARTITION" | grep '^Block size:' | tr -d ' ' | cut -d ':' -f 2)"
            minsize=$(sudo resize2fs -P "$PARTITION" | grep minimum | cut -d: -f2 | sed 's/ //g')
            if ! (( $minsize )); then
                minsize=0
            fi
            if [ $(is_number "$minsize") ] && [ $(is_number "$blocksize") ]; then
                FS_MIN=$(($minsize * $blocksize))
            fi
            ;;

        *)
            error $LINENO "fs '$FS-TYPE' unknown"
            ;;
    esac
    #echo $FS_TYPE
    echo $(bytes $FS_MIN -b)
}



media_filesystem_mount(){
    local PARTITION=$(media_device_fullname $1)
    local SILENT=$2
    
    if [[ -z $PARTITION ]]; then
        echo "Usage: diskutil mount partition"
        return
    fi
    
    media_device_checktarget $PARTITION part
    if (( $? )); then
        exit 1
    fi
    
    if [ -z "$(df | grep ^$PARTITION)" ]; then
        run_command "udisksctl mount -b $PARTITION" $LINENO 2>/dev/null
    fi
}
        
        
media_filesystem_unmount(){
     local PARTITION=$(media_device_fullname $1)
    
    if [[ -z $PARTITION ]]; then
        echo "Usage: diskutil umount partition"
        return
    fi
    
    media_device_checktarget $PARTITION part
    if (( $? )); then
        exit 1
    fi
    
    if [ ! -z "$(df | grep ^$PARTITION)" ]; then
        run_command "udisksctl unmount -b $PARTITION" $LINENO  2>/dev/null
    fi
    }        
    
    
    media_filesystem_name(){
    local PARTITION=$(media_device_fullname $1)
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    lsblk -n -o LABEL $PARTITION    
}
    
    
media_filesystem_size(){  
    local PARTITION=$(media_device_fullname $1)
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)    
    local FS_SIZE

#echo_blue "fs size $PARTITION"
#echo_blue "fs size $FS_TYPE"
#echo_blue $FS_TYPE
#exit

     
     case $FS_TYPE in
        fat16|fat32)
            #FS_SIZE=$(sudo fatresize -i "$PARTITION" | grep "Cur size" | cut -d: -f2 | sed 's/ //g')
            FS_SIZE=$(sudo fatresize -i "$PARTITION" | grep "Size:" | cut -d: -f2 | sed 's/ //g')
            #FS_SIZE=$(sudo fsck.fat -n -v $PARTITION | grep "data clusters" | cut -d\( -f2 | cut -d" " -f1)
            
      #      if [[ -z $FS_SIZE ]]; then
      #          FS_SIZE=$(sudo fatresize -i "$PARTITION" | grep "Cur size:" | cut -d: -f2 | sed 's/ //g')
      #      fi
                        
      #      if [[ -z $FS_SIZE ]]; then
                FS_SIZE=$(sudo fsck.fat -n -v $PARTITION | grep "data clusters" | cut -d\( -f2 | cut -d" " -f1)
      #      fi
            ;;
            
            
        exfat)
            FS_SIZE=$(sudo fsck.exfat  "$PARTITION" | grep Volume | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
            ;;     
            
            
        ntfs)
            #sudo ntfsfix -d $PARTITION
            # clear dirty bit
            sudo ntfsfix -d $PARTITION >> /dev/null
            FS_SIZE=$(sudo ntfsresize -i "$PARTITION" | grep "Current volume size:" | cut -d : -f2 | cut -d "b" -f1 | sed 's/ //g')
            ;;
            
        ext2|ext3|ext4)       
            blockcount="$(sudo tune2fs -l "$PARTITION" | grep '^Block count:' | tr -d ' ' | cut -d ':' -f 2)"
            blocksize="$(sudo tune2fs -l "$PARTITION" | grep '^Block size:' | tr -d ' ' | cut -d ':' -f 2)"
            if [[ $(is_number $currentsize) ]] && [[ $(is_number $blocksize) ]]; then
                FS_SIZE=$(($blockcount * $blocksize))
            fi
            ;;
            
        linux-swap*)
            FS_SIZE=1024
            ;;
            
        *)
            error $LINENO "Filesystem '$FS_TYPE' not known"
            ;;
    esac

    echo $(bytes $FS_SIZE -b)
}


media_filesystem_rename() {
    # changes the filesystem label.  NOT the Partition name
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil rename[Filesystem] partition newName"
        echo "Example: diskutil rename /dev/sda1 NEWDISK"
        return
    fi
    
    PARTITION=$(media_device_fullname $1)
    NAME="$2"
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    if [[ $(media_filesystem_ismounted $PARTITION) = true ]]; then
        echo $PARTITION is mounted
        return 1
    fi
    
    FS=$(lsblk $PARTITION -n -o FSTYPE)
    echo $FS
    
    case $FS in
        fat16|fat32)    run_command "sudo fatlabel $PARTITION '${NAME^^}'" ;;
        exfat)          run_command "sudo exfatlabel $PARTITION '$NAME'" ;;
        ntfs)           run_command "sudo ntfslabel $PARTITION '$NAME'" ;;
        ext4)           run_command "sudo e2label $PARTITION '$NAME'"    ;;
    esac
    
}


    
# -------------------------------------------------------------------------------
# partition low-level functions
# -------------------------------------------------------------------------------
media_partition_count(){
    local MEDIA=$1
    
     #parted_output="$(sudo parted -ms "$MEDIA" unit B print)"
     #partnum="$(echo "$parted_output" | tail -n 1 | cut -d ':' -f 1)"
     local last_part_num=$(sudo parted -ms "$MEDIA" unit B print |  tail -n 1 | cut -d ':' -f 1)
    
#echo_blue partition count part num $partnum
#exit
    if [[ $(is_number $last_part_num) = true ]]; then
        echo $last_part_num
    else
        echo 0
    fi
}


media_partition_num_start_end_size(){
    # returns the partition record.  num:start:end:size:fs-type:...
    # use '| cut -d: -f[1-5]' to get a column
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)  
    sudo parted -ms $DEVICE unit B print |  grep ^$PARTNUM:  | tr -d 'B'
    
}


#media_partition_partnum(){
#    local DEVICE=$(media_device_name $1)
#    local PARTNUM=$(media_device_partnum $1)
#    sudo parted -ms $DEVICE unit B print |  grep ^$PARTNUM: | cut -d ':' -f 1
#}

media_partition_start(){
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)    
    sudo parted -ms $DEVICE unit B print |  grep ^$PARTNUM:  | cut -d ':' -f 2 | tr -d 'B'
}


media_partition_end(){
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)    
    sudo parted -ms $DEVICE unit B print |  grep ^$PARTNUM:  | cut -d ':' -f 3 | tr -d 'B'
}


media_partition_size(){
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)    
    sudo parted -ms $DEVICE unit B print |  grep ^$PARTNUM: | cut -d ':' -f 4 | tr -d 'B'
}


media_partition_max(){
    # return the max end point of a partition
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1) 
    local PARTITION=$DEVICE$PARTNUM 
    local PART_START=$(media_partition_start $1) 
    local PART_END=$(media_partition_end $1) 
    local PART_FREE_START=$(($PART_END + 1))  
    local NEW_END
    
    if [[ -z $(sudo parted -ms $DEVICE unit B print free | grep ^$PARTNUM: ) ]]; then
        # partition number does not exist.
        return
    fi
    
    local PART_FREE_END=$(sudo parted -ms $DEVICE unit B print free | grep $PART_FREE_START | grep free | cut -d: -f3 | tr -d 'B')
    
    if [[ ! -z $PART_FREE_END ]]; then
        NEW_END=$PART_FREE_END
    else
        NEW_END=$PART_END
    fi    
    
    # if fat16 limit partition size to 4g
  #  if [[ $(media_filesystem_fs_type $PARTITION) = "fat16" ]] ; then
  #      local NEW_SIZE=$(( $NEW_END - $PART_START ))
  #      if [[ $NEW_SIZE -gt $(bytes 4090m -b) ]]; then
  #          NEW_END=$(( $PART_START + $(bytes 4090m -b) ))
  #      fi
  #  fi
    
    echo $NEW_END
}




########################################################################
########################################################################
# high level functions
3_high_level_functions(){  
    x=1 ; }
########################################################################


########################################################################   
# disk high level functions 
########################################################################


media_disk_info(){
    local DEVICE=$(media_device_fullname $1)
    
    if [[ -z $DEVICE ]]; then
        echo "Usage: diskutil info[rmation] device"
        exit
    fi

    #echo DiskInfo:
    echo Device: $DEVICE
    echo Partition table type: $(media_device_partition_table $DEVICE)
    echo
   
    #run_command "lsblk $TARGET -o name,path,mountpoint,fstype,pttype,ptuuid,partuuid,size,label,vendor,model" $LINENO
   # run_command "sudo parted $TARGET print free | grep -v Partition" $LINENO
    echo_white Displaying disk and partition info...
    run_command "sudo parted $DEVICE print free" $LINENO
    run_command "lsblk -f $DEVICE" $LINENO
   # echo
}


media_disk_verify() {
    local DISK=$1
     
    if [[ -z $DISK ]]; then
        echo "Usage: diskutil verifyDisk disk"
        return
    fi     
     
    media_device_checktarget $DISK disk 
    if (( $? )); then return 1; fi
    
    run_command "sudo parted $DISK print free" $LINENO
    
}


media_disk_repair() {
    local DISK=$1
     
    if [[ -z $DISK ]]; then
        echo "Usage: diskutil repairDisk disk"
        return
    fi 

    media_disk_verify $1
    
    echo "no changes made"
    echo "If you need to repair a partition, try using 'testdisk' "
}


media_disk_createpartitiontable(){
    local DEVICE=$(media_device_fullname $1)
    local PART_TABLE=${2:-msdos}   # msdos | gpt
    local SILENT=$3
    
    if [[ -z $1 ]];then
        echo "Usage: diskutil createPartitionTable device [gpt|msdos] [-y]"
        return 1
    fi
    
    
    if [[ $PART_TABLE = "dos" ]] ; then
        PART_TABLE=msdos
    fi
    
    
    if [[ $PART_TABLE = "msdos" ]] || [[ $PART_TABLE == "gpt" ]] ; then
        x=1
    else
        echo unsupported partition table type: $PART_TABLE
        return 2
    fi
         
    media_device_checktarget $DEVICE disk
    if (( $? )); then exit 1; fi    
    

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi
    
    # quit if is mounted
    if [[ ! -z "$(df | grep ^$DEVICE)" ]] ; then
        echo Error: $DEVICE is mounted
        echo Try diskutil unmountDisk $DEVICE
        df | grep ^$DEVICE
        return 1
    fi
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nCreate new '$PART_TABLE' partition table on '$DEVICE' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi
       
    echo "Writing zeros to '$DEVICE'..."
    run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

    echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
    run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO
    
}


media_disk_addpartition(){   
    if [[ -z $1 ]]; then
        echo "Usage: diskutil addPartition device [format] [size] [name] [-y]"
        echo "  Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4 | linux-swap"
        echo Example: diskutil addPartition ntfs Untitled 2G /dev/disk3
        echo Example: diskutil addPartition exfat NEWDISK 3G sda
        return
    fi
    
    local DEVICE=$(media_device_name $1)
    local FORMAT=${2:-fat32}    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=${4:-"NEW"}
    local SIZE=${3:-max}
    local SILENT=$5   # -y
    
    local DEVICE_SIZE=$(media_device_size $DEVICE)
    local LAST_PART_NUM=$(media_partition_count $DEVICE)
    local PART_NUM=$(( $LAST_PART_NUM + 1 ))
    
    local PART_TYPE=primary
    local FS_TYPE
    local BEG
    local END
    local END_BYTE
  
  
 
    
    media_device_checktarget "$DEVICE" disk 
    if (( $? )); then return 1; fi 

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi
    
    # Stop if dev is the root device
    if [[ $DEVICE = $(env_root_device) ]]; then
        ui_msg_error $LINENO "Format root device not allowed"
        return 3
    fi


     # set FS_TYPE       
    if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi

    # set BEG
    if [[ $LAST_PART_NUM -gt 0 ]]; then
        BEG=$(( $(media_partition_end $DEVICE$LAST_PART_NUM) + 1 ))
    else
        BEG=$(( 1024 * 1024 ))
    fi

    # set END
    case $SIZE in
        min)    
            END=$(( $BEG + $(( 1024 * 1024 )) ))   
            END_BYTE=$END
            ;;
        
        max)    
            END="100%"    
            END_BYTE=$(( $DEVICE_SIZE ))
            ;;
        
        *)      
            END=$(( $BEG + $(bytes $SIZE -b) )) 
            END_BYTE=$END
            ;;
    esac

        #check if END is past device size
        if [[ $END_BYTE -gt $DEVICE_SIZE ]]; then
echo_blue limiting size to $(bytes $(( $DEVICE_SIZE - $BEG )) -h )               
            END="100%"
        fi


    # limit fat16 to 4G
    if [[ $FS_TYPE = fat16 ]]; then
echo_blue Checking fat16 size...
        
        if [[ $(( $END_BYTE - $BEG )) -gt $(bytes 4090M -b) ]]; then
            echo limiting fat16 partition to 4g
          END=$(( $BEG + $(bytes 4090M -b) ))
          END_BYTE=$END
        fi
    fi 

echo_blue Add Partition ...
echo_blue "Device             =$DEVICE"
echo_blue "Device Size        =$(bytes $DEVICE_SIZE -h)"
echo
echo_blue $LAST_PART_NUM partitions
echo
echo_blue "New Partition size  =$(bytes $SIZE -h)"
echo_blue $BEG beg
echo_blue $END end
echo_blue $END_BYTE endbyte
#echo_blue $(bytes 4090M -b) 4G


    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi


# dumb patch

if [[ $(is_number $END) = true ]]; then
    END="$END"b
fi


       echo_white " - Creating partition on '$DEVICE'..."
       #mkpart part-type [fs-type] start end
     #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
  #      run_command "sudo parted -s -a opt $DEVICE mkpart $PART_TYPE '$PART_NAME' $FS_TYPE $BEG $END" $LINENO
    run_command "sudo parted -s -a opt $DEVICE mkpart $PART_TYPE $FS_TYPE "$BEG"b $END" $LINENO
  #  if (( $? )); then return 1; fi    


    # Check that the partition exists
        #local LAST_PART_NUM=$(media_partition_count $DEVICE)
        #local PART_NUM=$(( $LAST_PART_NUM + 1 ))
        if [[ $(media_partition_count $DEVICE) -ne $PART_NUM ]]; then
            echo_red Error. Add Partition unsuccessful  $LINENO
            return 1
        fi


    sleep 2
    echo_white " - Formatting the partition to '$FORMAT'..."
    #ui_echo "$PRODUCTNAME $SCRIPTVER Formatting the partition to '$FORMAT'..." white
    media_partition_format $DEVICE$PART_NUM $FORMAT $NAME $SILENT
  

    if (( $? )); then
        return 1
    else
        ui_msg "CREATE PARTITION" "~ '$FORMAT' Partition '$NEW_PARTITION' has been created." white "" log
    fi
    
}


media_disk_wipe(){
    local DEVICE=$(media_device_name $1)
    local PATTERN=${2:-zero}   # zero | random | shred
    local SIZE=${3:-max}
    local SILENT=${4:-n}  #-y or -n

    media_device_checktarget $DEVICE disk 
    if (( $? )); then
        return 1
    fi    
    
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
  #  local PART1=$DEVICE\1    
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    
    if [[ $SIZE = max ]]; then
        SIZE=$DEVICE_SIZE_BYTES
    else
        SIZE=$(bytes $SIZE -b)
    fi
    
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    #DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))
    DEVICE_BLOCK_COUNT=$(( $SIZE / $BLOCK_SIZE_BYTES ))

    if [ $1 = $ROOT ] ; then
        ui_msg  "Error 3" "Can not wipe root device"
        return 3
    fi

echo_blue size=$SIZE
echo_blue blocksize=$BLOCK_SIZE_BYTES
echo_blue block count=$DEVICE_BLOCK_COUNT
 
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "WIPE MEDIA" "All existing data on '$NAME' ($DEVICE) will be erased.  The device will be overwritten with $PATTERN.  Are you sure you want to continue? y/n?" "--defaultno")
        if [ $RESULT != "y" ]; then
            echo
            ui_msg "WIPE MMEDIA" "'$DEVICE' not erased"
            return
        fi
    fi
 
    #Countdown 
    do_beep
    ui_countdown 10 "" "Wiping Media '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "WIPE MEDIA" "Wipe Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    

    echo_white Wiping $DEVICE...

    echo Unmounting $DEVICE...
    sudo umount $DEVICE? 2>/dev/null

    if [[ $PATTERN = "shred" ]];then
        run_command "shred -v $DEVICE" $LINENO 
        return
    fi


    MESSAGE="Wiping '$NAME' ($DEVICE)\n\nWriting $PATTERN to $DEVICE... "  
    if [ $INTERFACE = "cli" ]; then
        echo_white "Writing $(bytes $SIZE -h) of $PATTERN to $DEVICE... "  
        pv -s $SIZE /dev/$PATTERN | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT
        EXIT_CODE=$?
    else
        (sudo pv -n -s $SIZE /dev/$PATTERN | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "WIPE MEDIA" --gauge "\n$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 5
        TEST_RESULTS=Failed
        return 5
    else
        TEST_RESULTS=Succeeded
        
    fi

    echo
    ui_msg "WIPE MEDIA" "'$NAME' ($DEVICE) has been wiped with zeros \n\nYou can remove the SD card from the reader"   
    
    pisafe_write_log "WIPE MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}



########################################################################
# filesystem high level functions 
########################################################################

media_filesystem_check() {
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)
    local PARTITION=$(media_device_fullname $1)
    local FIX=${2:-nofix}   # -y -n -a   yes, no, ask
    local WAS_MOUNTED=
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi


    # unmount
    if [[ $(media_filesystem_ismounted $PARTITION) ]] && [[ $(ui_yesno "Unmount and remount $PARTITION?" ) = y ]]; then
        echo
        echo "Unmounting $PARTITION ..."
        WAS_MOUNTED=true
        #umount $PARTITION
        media_filesystem_unmount $PARTITION
    fi
    
#echo_blue part=$PARTITION    
    FS_TYPE=$(media_filesystem_fs_type $PARTITION)
    
 #   ui_echo "FILESYSTEM='$FS_TYPE'"    
    echo_white Verifying $FS_TYPE file system... 
    
    case $FS_TYPE in
        fat16|fat32)           
            #ui_echo "Checking fat filesystem..." white log
            run_command "sudo fsck.fat -n -v $PARTITION" $LINENO   # -n means no-op
            RC=$?
            if (( $RC )); then
                ui_msg_error $LINENO "fsck.fat failed with rc $RC"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    echo
                    return 1
                fi
              
               media_filesystem_repair $PARTITION
               if (( $? )) ; then return 1; fi

            fi
            ;;
            
            
        exfat)
            #echo "Checking exfat filesystem..."
            run_command "sudo fsck.exfat -n $PARTITION" $LINENO   # -n is no-op
            rc=$?
            if (( $rc )); then
                error $LINENO "fsck.exfat failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    echo
                    return 1
                fi
                echo_white  "Attempting to repair filesystem..."
                media_filesystem_repair $PARTITION
                if (( $? )) ; then return 1; fi
            fi
            ;;
            
            
        ntfs)
            #echo " - Checking filesystem..."
            run_command "sudo ntfsfix -n $PARTITION" $LINENO      # fsck for ntfs.  limited.  -n no-op
            rc=$?
            
            if (( $rc )); then
                error $LINENO "ntfsfix failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    echo
                    return 1
                fi
                
                echo_white  "Attempting to repair filesystem..."
                media_filesystem_repair $PARTITION
                if (( $? )) ; then return 1; fi
            fi    
            ;;
            
        
        ext2|ext3|ext4)
            #echo "Checking ext_ filesystem"
            run_command "sudo e2fsck -fn $PARTITION"  $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "e2fsck failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    echo
                    return 1
                fi
                
                echo_white  "Attempting to repair filesystem..."
                media_filesystem_repair $PARTITION
                if (( $? )) ; then return 1; fi
            fi         
            ;;
            
 
        *)
            error $LINENO "Filesystem '$FILESYSTEM' not supported"
            #return 5
            exit
            ;;
    esac
    
    
     if [ $WAS_MOUNTED ]; then
        echo Remounting $PARTITION...
        media_filesystem_mount $PARTITION
    fi
    
    ui_echo "~ filesystem_check OK" green
}


media_filesystem_repair() {
    local PARTITION=$(media_device_fullname $1)
    local WAS_MOUNTED

    if [[ -z $PARTITION ]]; then
        echo "Usage: diskutil repairFilesystem partition"
        return
    fi
     
    media_device_checktarget $PARTITION part 
    if (( $? )); then return 1; fi 
    
    
    # unmount
    if [[ $(media_filesystem_ismounted $PARTITION) ]] && [[ $(ui_yesno "Unmount and remount $PARTITION?" ) = y ]]; then
        echo
        echo "Unmounting $PARTITION ..."
        WAS_MOUNTED=true
        #umount $PARTITION
        media_filesystem_unmount $PARTITION
    fi
    
    
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)
    echo_white Repairing $FS_TYPE file system... 
    
    case $FS_TYPE in
        fat16|fat32) 
         #   echo "Repairing fat filesystem..."
            run_command "sudo fsck.fat -a -w -v $PARTITION" $LINENO  # from gparted
            rc=$?
            if (( $rc )); then
                error $LINENO "fsck.fat failed with rc $rc"
                echo Recommend using Windows or DOS to run "chkdsk /f"
                return 1 
            fi
            ;;
            
        exfat)            
       #     echo "Repairing exfat filesystem..."
            run_command "sudo fsck.exfat -a $PARTITION"    $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "fsck.exfat failed with rc $rc"
                echo Recommend using Windows or DOS to run "chkdsk /f"
                return 1
            fi
            ;;
                
        ntfs)
            echo "Repairing ntfs filesystem..."
            run_command "sudo ntfsfix -d $PARTITION" $LINENO
             if (( $? )); then return 1 ; fi

            echo "Repairing ntfs filesystem..."         
            run_command "sudo ntfsresize -i -f -v $PARTITION" $LINENO    # from gparted
            rc=$?
            if (( $rc )); then          
                error $LINENO "failed with rc $rc"
                echo Recommend using Windows or DOS to run "chkdsk /f"
                return 1            
            fi    
                
            echo " - Check that ntfs filesystem is ready for resize..."     
            run_command "sudo ntfsresize -c $PARTITION" $LINENO   
            rc=$?
            if (( $rc )); then
                error $LINENO "ntfsresize failed with rc $rc"
                echo Error repairing filesystem.
                echo Recommend using Windows to run chkdsk 
                return 1
            fi    
           
            ;;
            
        ext2|ext3|ext4)
     #       echo "Repairing ext filesystem..."         
            run_command "sudo e2fsck -f -y -v -C 0 $PARTITION" $LINENO  # from gparted
            rc=$?
            if (( $rc )); then
                error $LINENO "fsck.exfat failed with rc $rc"
                echo Recommend using Windows or DOS to run "chkdsk /f"
                return 1
            fi

            #if [[ $repair == true ]]; then
            #    info "Trying to recover corrupted filesystem - Phase 2"
            #    sudo e2fsck -fy -b 32768 "$PARTITION"
            #    (( $? < 4 )) && return
            #fi
                
            #   run_command "sudo resize2fs $PARTITION"  $LINENO
            #   run_command "sudo e2fsck -pf $PARTITION" $LINENO
            #   run_command "sudo resize2fs $PARTITION"  $LINENO
     
            ;;
            
        *)
            echo Error unsupported file system $FS_TYPE
            exit
            ;;    
    esac
    
    if [ $WAS_MOUNTED ]; then
        echo Remounting $PARTITION...
        media_filesystem_mount $PARTITION
    fi
    
     ui_echo "~ filesystem_repair OK" green
}


media_filesystem_resize(){
    #Resize filesystemst run using both the -n and 
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil resizeFilesystem partition [min max size] "
        echo "Example:  "
        return
    fi
    
  #  local DEVICE=$(media_device_name $1)
  #  local PARTNUM=$(media_device_partnum $1)
    local PARTITION=$(media_device_fullname $1)
    local SIZE=${2:-max}  # min max bytes
    local NEW_SIZE
    local STARTING_SIZE=$(media_filesystem_size $PARTITION)
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)    

    echo_white "Check filesystem for errors and fix if possible ($LINENO)"
    media_filesystem_repair $PARTITION -y
    if (( $? )); then return 1; fi   
   

    echo_white "Resize '$FS_TYPE' filesystem to '$SIZE' "

    case $FS_TYPE in
    
        fat16|fat32)
            # You can't resize FAT32 partition lesser than 512Mb
             case $SIZE in
                 min)    
                    NEW_SIZE=$(sudo fatresize -i $PARTITION | grep Min | cut -d: -f2 | tr -d " ")
                    if [[ $NEW_SIZE < $(bytes 550M -b) ]]; then
                        NEW_SIZE=$(bytes 550M -b)
                    fi 
                    NEW_SIZE=" -s $(( $NEW_SIZE / 1024 ))k"
                    ;;
                max)                   
                    #NEW_SIZE=$(sudo fatresize -i $PARTITION | grep Max | cut -d: -f2 | tr -d " ") 
                    NEW_SIZE=$(( $(media_partition_max $PARTITION) - $(media_partition_start $PARTITION) ))
                    #NEW_SIZE=$(( $NEW_SIZE - $(bytes 1m -b ) ))
                    NEW_SIZE=" -s $(( $NEW_SIZE / 1024 ))k"
                    ;;
               
                 *) NEW_SIZE="-s $(( $(bytes $SIZE -b) / 1024 ))k"  ;;
             esac
        
            echo_white "Resizing fat filesystem to '$NEW_SIZE'... (line $LINENO)"
            #  run_command "sudo fatresize -p $NEW_SIZE $PARTITION" $LINENO
            run_command "sudo fatresize -q $NEW_SIZE $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "fatresize failed with rc $rc"
                return 1
            fi   
            
            sleep 2
            run_command "sudo fatresize -i $PARTITION" $LINENO
            if (( $? )); then return 1; fi
            ;;
            
        
        exfat)
            echo Can not resize exfat file systems.
            return
            ;;
            
                
        ntfs)
             case $SIZE in
                 min)    
                    NEW_SIZE="$(( $(media_filesystem_min $PARTITION) / 1024 ))k"
                    if [[ $(bytes $NEW_SIZE -b) < $(bytes 512m -b) ]]; then
                        NEW_SIZE=$(bytes 512m -b)
                    fi
                    NEW_SIZE="-s $NEW_SIZE"
                    ;;
                 max)    NEW_SIZE=""  ;;
                 *)      NEW_SIZE="-s $(( $(bytes $SIZE -b) / 1024 ))k"  ;;
             esac
            
            
            echo
            echo_white "Check filesystem is ready for resizing...line ($LINENO)"           
            run_command "sudo ntfsresize -c $PARTITION" $LINENO
            if (( $? )); then return 1; fi
            
            #test
            echo_white "Simulate resize ntfs fs... ($LINENO)"
            run_command "sudo ntfsresize --force --force $NEW_SIZE --no-action $PARTITION" $LINENO   # from gparted
            if (( $? )); then return 1; fi    
    
            #run
            echo_white "Resize ntfs fs...($LINENO)"
            run_command "sudo ntfsresize --force --force $NEW_SIZE $PARTITION" $LINENO    #from gparted
            if (( $? )); then return 1; fi
            
            
            
            sleep 2
            echo_white "Clear ntfs dirty flag... line ($LINENO)"
            run_command "sudo ntfsfix -d $PARTITION" $LINENO
            if (( $? )); then return 1; fi
            
            echo_white ntfs info...
            run_command "sudo ntfsresize -i $PARTITION" $LINENO
            if (( $? )); then return 1; fi
            echo
            sleep 2
            ;;
            
            
        ext2|ext3|ext4)
            case $SIZE in
                 min)    NEW_SIZE="-M" ;;
                 max)    NEW_SIZE=""  ;;
                 *)      NEW_SIZE="$(( $(bytes $SIZE -b) / 1024 ))k"  ;;
             esac
            
          #  NEW_SIZE=$(( $(bytes $NEW_SIZE -b) / 1024 ))K
            echo_white "Resizing $PARTITION to $NEW_SIZE"
            run_command "sudo resize2fs -p $PARTITION $NEW_SIZE" $LINENO    #from gparted
            if (( $? )); then return 1; fi
            sleep 2
            ;;       
            
            
       *)
            error $LINENO.
            ;;
            
    esac
    
    echo
    echo_white $PARTITION resized to from $(bytes $STARTING_SIZE -h) to $(bytes $(media_filesystem_size $PARTITION) -h)
}



retire_media_filesystem_resize_topart (){
    # resize a filesystem to fill a partition
    local PARTITION=$(media_device_fullname $1)
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)  
    local SIZEX
   

#DUMB patch... should not need
sleep 1       
FS_TYPE=$(media_filesystem_fs_type $PARTITION)  
        
    
#echo_blue FS_TYPE=$FS_TYPE

echo_white "Resizing the filesystem to fit the partition"
        
    case $FS_TYPE in
    
    fat16|fat32)
        SIZEX=$(($(media_partition_size $PARTITION) - 4194304))
        SIZEX=$(($SIZEX/1024))k
       # SIZEX=max
        run_command "sudo fatresize -v -p -s $SIZEX $PARTITION   " $LINENO
        if (( $? )); then return 1; fi
        ;;
        
    exfat)
        echo_red ERROR - CANT RESIZE exfat Filesystem
        ;;
    
    ntfs)
        #run_command "sudo ntfsresize -x $PARTITION" $LINENO       
        run_command "sudo ntfsresize --force --force $PARTITION" $LINENO   # from gparted  
        if (( $? )); then return 1; fi
        ;;
    
    ext4)
        run_command "sudo e2fsck -f $PARTITION" $LINENO             # from error message from resize2fs
        
        run_command "sudo resize2fs -p $PARTITION" $LINENO          # from gparted
        if (( $? )); then return 1; fi
        ;;
        
    *)
        echo_red "ERROR: Unsupported filesystem type '$FS_TYPE'" $LINENO
        ;;
        
    esac
    
}






########################################################################
# partition high level functions -----------------------------------------------------------------------------------------------

media_partition_info(){
    local DEVICE=$(media_device_name $1)
    local PARTITION_NUM=$(media_device_partnum $1)
    local PARTITION=$(media_device_fullname $1)
  #  local TARGET=$PARTITION
    local diff
    local WAS_MOUNTED=$(media_filesystem_ismounted $PARTITION)
    
#echo_blue "$PARTITION WAS_MOUNTED='$WAS_MOUNTED'"    
    
    if [[ -z $DEVICE ]]; then
        echo "Usage: diskutil info[rmation] device"
        exit
    fi
    
    
    #echo DiskInfo:
    #echo Partition table type: $(media_device_partition_table $TARGET)
   
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    
    
    # mount the partition silently
    #media_filesystem_mount $TARGET
#echo_blue mount...    
    udisksctl mount -b $PARTITION   2>/dev/null
    
    echo_white Displaying disk and partition info...
    run_command "sudo parted $PARTITION print free" $LINENO
    run_command "lsblk -f $PARTITION" $LINENO
    echo
    
    # unmount if it was not mounted
#echo_blue "$PARTITION WAS_MOUNTED 2='$WAS_MOUNTED'" 
    if [[ -z $WAS_MOUNTED ]] ;then
        #media_filesystem_unmount $TARGET 
#echo_blue unmount because it was not mounted              
        udisksctl unmount -b $PARTITION  2>/dev/null
    fi
    
    
#echo_blue $PARTITION
#echo_blue "$PARTITION ismounted='$(media_filesystem_ismounted $PARTITION)'"

    # unmount if mounted and yes
    if [[ ! -z $(media_filesystem_ismounted $PARTITION) ]]  && [[ $(ui_yesno "Unmount then remount $PARTITION?" ) = y ]]; then
        echo
        echo "Unmounting $PARTITION ..."
        media_filesystem_unmount $PARTITION
    fi
    echo

  #  lsblk -b /dev/sda1 -p -o name,pttype,size,fstype,label,fssize,fsused

    
    # gather partition info...
    echo Gathering partition info...
    
    local DEVICE_NAME=$(media_device_name $PARTITION)
    local DEVICE_SIZE=$(media_device_size $PARTITION)
    local PART_TABLE=$(media_device_partition_table $PARTITION)
    
  #  local PART_START=$(media_partition_start $PARTITION)
  #  local PART_END=$(media_partition_end $PARTITION)
  #  local PART_SIZE=$(media_partition_size $PARTITION)
    local PART_MAX_END=$(media_partition_max $PARTITION)
    
    local FS_TYPE=$(media_filesystem_fs_type $PARTITION)
    local FS_NAME=$(media_filesystem_name $PARTITION)
    local FS_SIZE=$(media_filesystem_size $PARTITION)
    local FS_MIN=$(media_filesystem_min $PARTITION)
   
   
    # new idea ...
    local PART_RECORD=$(media_partition_num_start_end_size $PARTITION)
    local PART_START=$(echo $PART_RECORD | cut -d: -f 2)
    local PART_END=$(echo $PART_RECORD | cut -d: -f 3)
    local PART_SIZE=$(echo $PART_RECORD | cut -d: -f 4)
 #   local PART_FS_TYPE=$(echo $PART_RECORD | cut -d: -f 5)
    
    
    
    if [[ $(is_number $PART_SIZE) = true ]] && [[ $(is_number $PART_END) = true ]] && [[ $(is_number $PART_START) = true ]]; then  
        p_diff=$(( $PART_SIZE - $PART_END  + $PART_START ))   # (($PART_SIZE-$PART_END+$PART_START))
    else
        p_diff=unknown    
    fi
 
 
    # if [[ $(is_number $P_SIZE) ]] && [[ $(is_number $FS_SIZE) ]]; then  
    if [[ $(is_number $PART_SIZE) = true ]] && [[ $(is_number $FS_SIZE) = true ]]; then  
        fs_diff=$(($PART_SIZE - $FS_SIZE))
    else
        fs_diff=unknown
    fi
 
    
    echo
    echo_blue "=======   PARTITION INFO   ============"
    echo "DEVICE       = $DEVICE_NAME"
    echo "DEVICE_SIZE  = $(bytes $DEVICE_SIZE -h)      '$DEVICE_SIZE' " 
    echo "Partition tbl= $PART_TABLE"  
    echo
 #   echo "PARTITION    = '$(media_device_fullname $DEVICE)'" 
    echo "PARTNUM      = '$(media_device_partnum $PARTITION)'"  
    echo "PARTITION    = '$PARTITION'"  
    echo "PART_START   = $(bytes $PART_START -h)      '$PART_START' "   
    echo "PART_END     = $(bytes $PART_END -h)      '$PART_END'  "          
    echo_white "PART_SIZE    = $(bytes $PART_SIZE -h)      '$PART_SIZE'   ($p_diff b larger than calc)"
    echo "PART_MAX_END = $(bytes $PART_MAX_END -h)      '$PART_MAX_END'  "

    echo
    echo "FS_TYPE      = $FS_TYPE"  
    echo "FS NAME      = $FS_NAME"
    echo_white "FS_SIZE      = $(bytes $FS_SIZE -h)      '$FS_SIZE'   ($fs_diff b smaller than partition)"   
    echo "FS_MIN       = $(bytes $FS_MIN -h)      '$FS_MIN' " 
    
    if [[ $fs_diff -lt 0 ]]; then
        new_end=$(( $PART_START + $FS_SIZE ))
        echo "try sudo parted $DEVICE_NAME unit B resizepart $(media_device_partnum $PARTITION) $new_end "
    fi
    
    
    # mount
    if [[ -z $(media_filesystem_ismounted $PARTITION) ]] && [[ ! -z  $WAS_MOUNTED ]] ; then
        echo
        echo "Mounting $PARTITION ..."
        media_filesystem_mount $PARTITION
    fi
    
}













        
        






retire_media_name(){
    #lsblk -dpnlo NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    local VEN_MOD=$(lsblk -dpnlo VENDOR,MODEL $1  2> /dev/null | sed 's/  */ /g')
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    local SIZE=$(lsblk -dpnlo SIZE $1  2> /dev/null | sed 's/[ ]\+//g')
    local DEVICE=$(lsblk -dpnlo NAME $1  2> /dev/null)
    
    echo "$VEN_MOD - $SIZE ($DEVICE)"
}








retire_media_disk_partition () {
    if [[ -z $1 ]]; then
        echo "Usage: disktuil partitionDisk device type filesystem [name] [size]"
        echo "type is: gpt | msdos | mac"
        echo "filesystem is: fat16 fat32 exfat ntfs ext2 ext3 ext4 free"
        echo "Example: diskutil partitionDisk sda gpt"
        eche "Note: this does not work"
        return
    fi
    
    local DEVICE=$1
    local TYPE=$2
    local FILESYSTEM=$3
    local NAME=${4:-$(media_size $DEVICE -h)} 
    local SIZE=${5:-100%} 
    
    media_device_checktarget $DEVICE disk
    if (( $? )); then exit 1; fi    
    
    
     if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
    # ui_msg  "INSTALL:" "$MSG" "white" "OK" "log"
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi   
    
    
exit    
    
    echo "Writing zeros to '$DEVICE'..."
    run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

    echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
    run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO
    
    
}


media_disk_delpartition(){
    local DEVICE=$(media_device_name $1)
    local PARTNUM=$(media_device_partnum $1)
    local PARTITION=$DEVICE$PARTNUM
    local SILENT=$2
    
    if [[ -z $1 ]]; then
        echo "Usage: disktuil delPartition partition [-s]"
        echo "Example: diskutil delPartition sda1"
        return
    fi 
    
    media_device_checktarget $DEVICE disk
    if (( $? )); then exit 1; fi    
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi
    
    echo "Unmounting $DEVICE$PART_no"
    media_filesystem_unmount $PARTITION

    # if swap_partition
    if [[ ! -z $(swapon --show | $PARTITION) ]]; then
        run_command "sudo swapoff $PARTITION" $LINENO
        if (( $? )); then return 1; fi

    fi

    
    echo "Deleting partition $PART_NO on '$DEVICE '..."
        #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
    run_command "sudo parted $DEVICE rm $PARTNUM" $LINENO

}




media_disk_mount(){
    local TARGET=$(media_device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil mountDisk device"
        echo "Attempts to mount all filesystems on device"
        return
    fi
    
    media_device_checktarget $TARGET disk
    if (( $? )); then
        exit 1
    fi
   
    PARTITION_COUNT=$(media_partition_count $TARGET)
 #  for ((i = 0 ; i <= 1000 ; i++)); do
    
    for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
         if [ -z "$(df | grep ^$TARGET$PART)" ]; then
            run_command "udisksctl mount -b $TARGET$PART" $LINENO 2>/dev/null
         fi   
    done
}        

    
media_disk_unmount(){
    local TARGET=$(media_device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil umountDisk device"
        echo "Attempt to unmount all the directly-mountable volumes on the disk."
        return
    fi
    
    media_device_checktarget $TARGET disk
    if (( $? )); then exit 1; fi
    
    PARTITION_COUNT=$(media_partition_count $TARGET)
    
    for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
        if [ ! -z "$(df | grep ^$TARGET$PART)" ]; then
            run_command "udisksctl unmount -b $TARGET$PART" $LINENO  2>/dev/null
        fi    
    done    
    }    


media_disk_eject(){
        if [[ -z $1 ]]; then
            echo "Usage: diskutil eject device"
            exit
        fi      
        
        DEVICE=$(media_device_fullname $1)
        
        media_device_checktarget $DEVICE disk
        if (( $? )); then
            exit 1
        fi
        
        media_disk_unmount $DEVICE
        run_command "udisksctl power-off -b $DEVICE" $LINENO
}


media_disk_format(){
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil eraseDisk device [format] [name]"
        echo "Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4"
        echo Example: diskutil eraseDisk ntfs Untitled /dev/disk3
        echo Example: diskutil eraseDisk exfat NEWDISK /dev/sda
        return
    fi

    local DEVICE=$(media_device_fullname $1)
    local FORMAT=${2:-fat32}    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=${3:-NEW}
    
    local SILENT=$4   # -y
    local SIZE=max
    
    
    media_device_checktarget "$DEVICE" disk 
    if (( $? )); then
        return 1
    fi 
    
    local ROOT="$(env_root_device)"
    local TYPE="$(lsblk $DEVICE -dnpo TYPE)"
   # local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE,TYPE) ($DEVICE)"
    local PARTITION=$DEVICE

	if [[ ${FORMAT:0:3} = fat ]] ; then   
		PART_TABLE=msdos
	#	PART_TYPE=primary
#		PART_NAME=
	else
		PART_TABLE=gpt
#		PART_TYPE=
#		PART_NAME=PART1    
	fi

	if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi


    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi


    echo "Unmounting '$DEVICE'..."
    media_disk_unmount $DEVICE

    echo_white " - Step 1: Create new partition table..."
    media_disk_createpartitiontable $DEVICE $PART_TABLE -y
    if (( $? )); then return 1; fi
    echo_green DONE


echo_blue $SIZE



    echo_white "- Step 2: Add a partition to '$DEVICE'..."
    media_disk_addpartition $DEVICE $FORMAT max $NAME -y
    if (( $? )); then return 1; fi
    echo_green DONE
  
    # mount the drive with udisksctl if installed
    media_filesystem_mount $DEVICE\1

}





#######################################################################
# partition high level functions
#######################################################################


media_partition_rename () {
    local PARTITION=$1
    local PARTITION_NUMB=
    local NAME=$2
    
    run_command 'sudo parted $PARTITION name "$NAME"' $LINENO
}



media_partition_resize(){
    local DEVICE=$(media_device_name $1)
    local PART_NUM=$(media_device_partnum $1)
    local PARTITION=$(media_device_fullname $1)
    local SIZE=${2:-max}
    local SILENT=$3
    local FS_SIZE
    local NEWSIZE   
    
    
    if [[ -z $1 ]]; then
        echo "Usage: disutil resizePartition partition [min max size]"
        echo "example diskutil resizePartition sda1 min"
        return
    fi
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    if [[ $(media_filesystem_fs_type $PARTITION) = exfat ]]; then
        echo Cannot resize exfat filesystems
        return 1
    fi
    
    if [[ $(media_filesystem_ismounted $PARTITION) = true ]]; then
        echo $PARTITION is mounted
        return 1
    fi

    
    
    FS_SIZE=$(media_filesystem_size $PARTITION)
    
    case $SIZE in
        min)    NEW_SIZE=$(media_filesystem_min $PARTITION)       ;;
        
        max)    NEW_SIZE=$(( $(media_partition_max $PARTITION) - $(media_partition_start $PARTITION)  ))    ;;
        
        *)      NEW_SIZE=$(bytes $SIZE -b)       ;;
    esac
    
    echo $FS_SIZE
    echo $NEW_SIZE
    
    sleep 2
    echo_white "Step 1: Checking filesytem on $PARTITION..."
    media_filesystem_check $PARTITION
    if (( $? )); then
        echo Errors on filesystem $PARTITION. Cannot resize.
        echo run 'disutil repairPartition $PARTITION', then retry this.
        return 1
    fi    
    
    sleep 2
    echo
    echo_white "Step 1.5: Repairing filesystem before resize..."
    media_filesystem_repair $PARTITION
    if (( $? )); then
        echo Errors on filesystem $PARTITION. Cannot resize.
        return 1
    fi     
    
    
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "RESIZE PARTITION" "WARNING!!  \n\nResize '$DEVICE' to '$(bytes $NEW_SIZE -h)'.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "RESIZE PARTITION" "~ $DEVICE not resized. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "RESIZE PARTITION"  # "Resizing Partition '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
    # ui_msg  "INSTALL:" "$MSG" "white" "OK" "log"
        ui_msg  "RESIZE PARTITION"  "~ Resize Partition stopped." "" "" log
        return 2
    fi
    

    
    
    # shrink
    if [[ $NEW_SIZE -lt $FS_SIZE ]]; then
        echo_green Shrink...
        
        echo_white " - Step 2: Shrink the FILESYSTEM to ..."
        media_filesystem_resize $PARTITION $SIZE
        if (( $? )); then return 1; fi
        
        sleep 1
        echo_white " - Step 3: Shrink PARTITION to fit FILESYSTEM..."   
        media_partition_resize_tofs $PARTITION    
        if (( $? )); then return 1; fi
    fi
    
    
    
    # grow
    if [[ $NEW_SIZE -gt $FS_SIZE ]]; then
        echo_green Grow...
        
        echo_white " - Step 2: Grow the PARTTITION... " 
        media_partition_resize_grow $NEW_SIZE $PARTITION
        if (( $? )); then return 1; fi
        
        sleep 1
        echo_white " - Step 3: Grow FILESYSTEM to fit PARTITION..."
        #media_filesystem_resize_topart $PARTITION
        media_filesystem_resize $PARTITION max
        if (( $? )); then return 1; fi
    fi  
      
      
      
    sleep 1    
    echo_white " - Step 4: Checking filesytem on $PARTITION..."
    media_filesystem_check $PARTITION
    if (( $? )); then
        echo_red Errors on filesystem $PARTITION after resizing.
        return 1
    fi      
      
}


media_partition_resize_tofs(){
        # resize a partition to match the filesystem size
        
        local PARTITION=$(media_device_fullname $1)
        local DEVICE=$(media_device_name $PARTITION)
        local PART_NUM=$(media_device_partnum $PARTITION)
        local END_FS
        END_FS=$(($(media_partition_start $PARTITION) + $(media_filesystem_size $PARTITION) + $(( 1024 * 1024 )) ))

#echo_blue  part start:$(media_partition_start $PARTITION) 
#echo_blue fs size:$(media_filesystem_size $PARTITION)   
#echo_blue end fs:$END_FS   


        # skip if fat32
        local FS_TYPE=$(media_filesystem_fs_type $PARTITION)
        if [[ $FS_TYPE = fat32 ]]; then
            echo_white fat32 partitions automatically resize
            return
        fi


        echo_white "Resizing the partition to fit the file system"
        run_command "sudo parted $DEVICE unit B resizepart $PART_NUM $END_FS" $LINENO
}


media_partition_resize_grow(){
        # grow a partition to a size
        local SIZE=$1
        local PARTITION=$2
        
        
        
        # skip if fat32
        local FS_TYPE=$(media_filesystem_fs_type $PARTITION)
        if [[ $FS_TYPE = fat32 ]]; then
            echo_white fat32 partitions automatically resize
            return
        fi
        
        

        local DEVICE=$(media_device_name $PARTITION)
        local PART_NUM=$(media_device_partnum $PARTITION)
        local END_FS
        
        SIZE=$(bytes $SIZE -b)
        
        END_FS=$(( $(media_partition_start $PARTITION) + $SIZE ))
        
   #     echo_white Resizing the partition...
        
        run_command "sudo parted $DEVICE unit B resizepart $PART_NUM $END_FS" $LINENO
}

retire_media_size() {
    local DEV=$1
    local HUMAN=${2:-"no"}
   
     # add '/dev/' if missing
    if [[ ${DEV:0:5} != "/dev/" ]]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        DEV="/dev/"$DEV
    fi
   
    SIZE_BYTES=$(lsblk $DEV -dnbo size  2> /dev/null)
    RC=$?
    if (( $RC )); then
        echo 0
        return $RC       
    fi
    
    if [[ $HUMAN = "-h" ]]; then
        echo $(bytes $SIZE_BYTES -h)
    else
        echo $SIZE_BYTES
    fi
    
    # an alternative way:
    # echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
    # echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


media_partition_format(){
    local PARTITION=$(media_device_fullname $1)
    local FORMAT=${2:-fat32}
    local FS_NAME=${3:-NEW}
    local SILENT=$4
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil erasePartition partition [format] [name] [-y]"
        exit
    fi
    
  #  if [[ -z $PARTITION ]] ; then
  #      ui_msg_error $LINENO "Partition not specified."
  #      lsblk -dp
  ##      exit 1
   # fi
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1; fi
    
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
    # ui_msg  "INSTALL:" "$MSG" "white" "OK" "log"
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi

    
    echo "Unmounting 'PARTITION'..."
    #run_command "sudo umount $DEVICE 2> /dev/null"
    media_filesystem_unmount $PARTITION
    
    echo_white " - Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat16)  
            run_command "sudo mkfs.vfat -F16 -v -I -n ${FS_NAME^^} $PARTITION" $LINENO
            ES=$?
            ;;

        fat32)
            run_command "sudo mkfs.vfat -F32 -v -I -n ${FS_NAME^^} $PARTITION" $LINENO
            ES=$?
            ;;
            
        exfat)
            run_command "sudo mkfs.exfat -n ${FS_NAME^^} $PARTITION" $LINENO
            ES=$?
            ;;      
        
        ntfs)
          #  run_command "sudo mkfs.ntfs -f -L $FS_NAME $PARTITION" $LINENO
            run_command "sudo mkntfs -Q -v -F -L $FS_NAME $PARTITION" $LINENO   # from gparted
            ES=$?
            ;;
        
        ext2 | ext3 | ext4)
            run_command "sudo mkfs -t $FORMAT -L $FS_NAME -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            ES=$?
            ;;
            
        ext4)
            run_command "sudo mkfs.ext4 -F -O ^64bit -L $FS_NAME $PARTITION" $LINENO    # from Gparted
            ES=$?
            ;;
            
        linux-swap)
            run_command "sudo mkswap -L '' $PARTITION" $LINENO  # from gparted
            ES=$?
            ;;
            
        hfs)
            run_command "sudo mkfs.hfs -v $FS_NAME $PARTITION" $LINENO
            ES=$?
            ;;
            
        *)
            ui_msg_error $LINENO "Unknown format '$FORMAT'"
    esac

    if (( $ES )); then
  #      ui_msg_error $LINENO "mkfs failed"
        return 1
    else
        ui_msg "ERASE MEDIA" "~ Format complete. '$PARTITION' has been erased." white "" log
    fi

    echo "Mounting the drive..."
    sleep 2
    media_filesystem_mount $PARTITION
      
}


media_partition_reformat(){
    local PARTITION=$(media_device_fullname $1)
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil reformat partition [-y]"
        echo Example: diskutil reformat /dev/sda1
        return
    fi
    
    media_device_checktarget $PARTITION part
    if (( $? )); then return 1 ; fi
    

    FS=$(media_filesystem_fs_type $PARTITION)
    NAME=$(media_filesystem_name $PARTITION)
    
    if [[ "$FILESYSTEMS" != *"$FS"* ]]; then
        echo $FS is not a supported filesystem
        return 1
    fi
    
  

    media_partition_format $PARTITION $FS "$NAME"  $2
}




retire_media_disk_formatxx(){
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil eraseDisk format name device"
        echo "Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4"
        echo Example: diskutil eraseDisk ntfs Untitled /dev/disk3
        echo Example: diskutil eraseDisk exfat NEWDISK /dev/sda
        return
    fi

    local FORMAT=${1:-"fat32"}    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=$2
    local DEVICE=$(device_fullname $3)
    local SILENT=$4   # -y
    
    
#echo $NAME
#exit    
    
    media_device_checktarget "$DEVICE" disk 
    if (( $? )); then
        return 1
    fi 
    
    local ROOT="$(env_root_device)"
    local TYPE="$(lsblk $DEVICE -dnpo TYPE)"
   # local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE,TYPE) ($DEVICE)"
    local PARTITION=$DEVICE

	if [[ ${FORMAT:0:3} = fat ]] ; then   
		PART_TABLE=msdos
		PART_TYPE=primary
		PART_NAME=
	else
		PART_TABLE=gpt
		PART_TYPE=
		PART_NAME=PART1    
	fi

	if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi
	

    if [[ -z $DEVICE ]] ; then
        ui_msg_error $LINENO "Device not specified."
        lsblk -dp
        return 1
    fi

    if [[ ! -e $DEVICE ]]; then
        ui_msg_error $LINENO "'$DEVICE' does not exist"
        return 2
    fi

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi
    
    # Stop if dev is the root device
    if [[ $DEVICE = $(env_root_device) ]]; then
        ui_msg_error $LINENO "Format root device not allowed"
        return 3
    fi

    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi




    echo "Unmounting '$DEVICE'..."
    sudo umount $DEVICE 2> /dev/null
    sudo umount $DEVICE? 2> /dev/null

    # if selected whole disk... wipe the partition table and make a new partition table.
    if  [[ $TYPE = disk ]]; then
       
        echo "Writing zeros to '$DEVICE'..."
        run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

        echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
        run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO




        echo "Creating partition on '$DEVICE'..."
     #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
     
        # need to limit size to 4G if fat16    
        if [[ $FS_TYPE = fat16 ]] && [[ $(media_size $DEVICE) -gt $(bytes 4G) ]]; then
            SIZE=4G
        else
            SIZE=100%
        fi           

        run_command "sudo parted -s -a opt $DEVICE mkpart $PART_TYPE $PART_NAME $FS_TYPE 1M $SIZE" $LINENO
        
      #  echo "Set Partition name to ..."
        #run_command "   " $LINENO
        
        PARTITION=$DEVICE\1    
    fi    

    sleep 2
    echo "Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat16) 
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -F16 -v -I -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;

        fat32)
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -v -I -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;
            
        exfat)
            #https://unix.stackexchange.com/questions/61209/create-and-format-exfat-partition-from-linux
            if [[ -z $(which mkfs.exfat) ]] ; then
                echo Installing exfat support ...
                sudo $INSTALL exfat-utils 
                sudo $INSTALL exfat-fuse 
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi    
            run_command "sudo mkfs.exfat -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;      
        
        ntfs)
            if [[ -z $(which mkfs.ntfs) ]] ; then
                #sudo apt-get install fuse ntfs-3g
                echo Installing ntfs support...
                sudo $INSTALL fuse 
                sudo $INSTALL ntfs-3g 
                sudo $INSTALL ntfsprogs  #ntfsprogs is for arch
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi  
            run_command "sudo mkfs.ntfs -f -L '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;
        
        ext2 | ext3 | ext4)
          #  run_command "sudo mkfs -t $FORMAT -L $NAME -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            run_command "sudo mkfs -t $FORMAT -L '$NAME' -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            ES=$?
            ;;
            
        *)
            ui_msg_error $LINENO "Unknown format '$FORMAT'"
            
    esac

    if (( $ES)); then
  #      ui_msg_error $LINENO "mkfs failed"
        return 1
    else
        ui_msg "ERASE MEDIA" "~ Format complete. '$(media_name $DEVICE)' has been erased." white "" log
    fi

    # mount the drive with udisksctl if installed
    if [[ $(env_which udisksctl) ]]; then
        echo "Mounting the drive..."
        sleep 2
        run_command "udisksctl mount -b $PARTITION" $LINENO
        if (( $? )); then
            ui_msg_warning $LINENO "mount failed"
            return 1
        fi
    fi    
}




#######################################################################

media_clone(){
    SOURCE=$1
    TARGET=$2
    

    # get info
 #   if [[ $SKIP_FREESPACE = "on" ]]; then

		START_OF_FREESPACE=$(sudo parted -ms "$SOURCE" unit B print free)
		RC=$?
		if (( $RC )); then
			error $LINENO "parted failed with rc $RC"
            do_beep_down
			exit 15
		fi
		START_OF_FREESPACE=$(tail -1 <<< "$START_OF_FREESPACE" | grep free | cut -d ':' -f 2 | tr -d 'B')
		if ! (( $START_OF_FREESPACE )); then 
			START_OF_FREESPACE=$(media_size $SOURCE)
		fi

		BYTES_TO_READ=$START_OF_FREESPACE
		BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1 ))

		echo Media size=$(media_size $SOURCE -h)
		echo Skipping $(bytes $(( $(media_size $INDEV) - $START_OF_FREESPACE )) -h ) of freespace at end.
		echo Reading=$(bytes $START_OF_FREESPACE -h)

#	else
	  BYTES_TO_READ=$(media_size $INDEV)
	  BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

#	fi    
	#end of new section    
    
    # check if there is space
    SOURCE_SIZE=$(sudo lsblk -ndb $SOURCE -o size)
    TARGET_SIE=$()    
        
    # ask to procede
    
    #do it
    #sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
    if [[ ! -z $(which pv) ]]; then
#		sudo pv $SOURCE -s $BYTES_TO_READ | dd bs=$BS of=$TARGET count="$BLOCKS_TO_READ" iflag=fullblock conv=fsync 
		RC=$?
    else
      echo "Note: 'pv' is not installed so there is no progress indicator for this step. Please wait..."
#      sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img  conv=fsync 
      RC=$?
    fi
    if (( $RC )); then
        do_beep_down
        return $RC
    fi
}





media_test_pattern(){
    local DEVICE=$1
    local PATTERN=$2   # in octal  eg '\377'
    
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local ROOT="/dev/$(env_root_device)"
    local TEMP_FILE=tmpfile.img


    if [ ! -e $DEVICE ]; then
      ui_msg  "Error 2" "$DEVICE does not exist"
      return 2
    fi
    
    if [ $1 = $ROOT ] ; then
        ui_msg  "Error" "Can not test root device"
        return 1
    fi
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    
    # block=4M
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))
  
# just do 2% for testing
#DEVICE_BLOCK_COUNT=$(( $DEVICE_BLOCK_COUNT / 20 ))

     
    date 
    TIME1=$(date +%s)
    MESSAGE="$MESSAGE \nTESTING $PATTERN\nStep 1 of 3: Writing  ... "
#    if [ $INTERFACE = "cli" ]; then
        echo_white "Step 1 of 3: Writing '$PATTERN'..."   
        tr '\000' $PATTERN  </dev/zero | sudo pv -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT 
        EXIT_CODE=$?
#    else
#        (tr '\000' $PATTERN </dev/zero | sudo pv -n -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT ) 2>&1  \
#        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0 
#        EXIT_CODE=$?
#    fi    
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "ERROR 1" "Writing" "red"
        return 1
    fi
    
#######
#sudo hexedit /dev/sdb

    
    date
    TIME2=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME1 $TIME2))\nStep 2 of 6: Reading  ... "
#     if [ $INTERFACE = "cli" ]; then
        echo_white "Step 2 of 3: Reading '$PATTERN' ..."
        sudo pv -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock 
        EXIT_CODE=$?
#     else
#        (sudo pv -n -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock) 2>&1 \
#        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0 
#        EXIT_CODE=$?
#     fi
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "ERROR 2" "Reading" "red"
        return 2
    fi
    
    
    date
    TIME3=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME2 $TIME3))\nStep 3 of 6: Comparing... "
 #   if [ $INTERFACE = "cli" ]; then
        echo_white "Step 3 of 3: Compare '$PATTERN'..."
        pv -s $DEVICE_SIZE_BYTES <(tr -dc $PATTERN <$TEMP_FILE) | cmp $TEMP_FILE
        EXIT_CODE=$?
 #   else
  #      (pv -n -s $DEVICE_SIZE_BYTES <(tr -dc $PATTERN <$TEMP_FILE) | cmp $TEMP_FILE) 2>&1 \
  #      | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
  #      EXIT_CODE=$?
 #   fi
    
#echo ec=$ec
#echo EC=$EXIT_CODE    
#EXIT_CODE=$ec
    
    date
    TIME4=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME3 $TIME4))"
  
    if [ $EXIT_CODE != 0 ]; then
        #ui_msg "ERROR 3" "Comparing" "red"
        MESSAGE="$MESSAGE\nFAILED "
        return 3
    else    
        MESSAGE="$MESSAGE\nPASSED "
    fi
}



media_test(){
    local DEVICE=$1
    local SILENT=${2:-"-n"}
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    #  local ROOT="/dev/$(env_root_device)"
    #  local TEMP_FILE=tmpfile.img
    MESSAGE=
    # ones  = '/377'     = 11111111
    # zeros = '/000'     = 00000000
    # alt   = '/125'     = 01010101
    
    if [ ! -e $DEVICE ]; then
      ui_msg  "Error 2" "$DEVICE does not exist"
      return 2
    fi
    if [ $SILENT != '-y' ]; then
        MSG="WARNING!! '$NAME' ($DEVICE) will be completely erased in testing.  Back it up first if needed.  \n\nThis will switch to a terminal screen to do the testing.  \n\nAre you sure you want to continue?"
        RESULT=$(ui_yesno "TEST MEDIA '$NAME' $DEVICE" "$MSG" "--defaultno")
        if [ $RESULT != 'y' ] ; then
          return 3
        fi
    fi
    
    # countdown
    do_beep
    ui_countdown 10 "" "Overwriting '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        #whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA" --msgbox "Test Media stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
		ui_msg	"TEST MEDIA" "Test Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    
    
    OLD_INTERFACE=$INTERFACE
    
    echo_white Unmounting $DEVICE...
    umount $DEVICE? 2> /dev/null
    
    #test with ones \377
    TIME1=$(date +%s)
    media_test_pattern $1 '\377'
    ONES_COMPARE=$?
    if (( $ONES_COMPARE )) ; then
      echo "error in testing ones"
    fi
    
    #test with zeros \000
    TIME2=$(date +%s)
    media_test_pattern $1 "\000"
    ZEROS_COMPARE=$?
    if (( $ZEROS_COMPARE )) ; then
      echo "error in testing zeros"
    fi
  
    INTERFACE=$OLD_INTERFACE
  
    #summary
    TIME3=$(date +%s)
    if [ $ZEROS_COMPARE = 0 ] && [ $ONES_COMPARE = 0 ]; then
       TEST_RESULTS="PASSED"
    else
        TEST_RESULTS="FAILED"
    fi  
    
    
    MESSAGE="$MESSAGE\n\nMedia Test $TEST_RESULTS ($(get_elapsed_time $TIME1 $TIME3))"
    ui_msg "TEST MEDIA '$NAME' $DEVICE"  "$MESSAGE"
    
    pisafe_write_log "TEST MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}



whiptail_calc_wt_size() {
    # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
    # output from tput. However in this case, tput detects neither stdout or 
    # stderr is a tty and so only gives default 80, 24 values

    WT_HEIGHT=20
    WT_WIDTH=80
    WT_HEIGHT_TALL=$(($(tput lines)-10))
    WT_WIDTH_WIDE=$(($(tput cols)-7))
    
    if [[ $WT_WIDTH_WIDE -gt 120 ]]; then
        WT_WIDTH_WIDE=120
    fi

    if [[ -z $WT_WIDTH ]] || [[ $WT_WIDTH -lt 60 ]]; then
        WT_WIDTH=80
    fi
    if [[ $WT_WIDTH -gt 178 ]]; then
        WT_WIDTH=80
    fi

    WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
    WT_MENU_HEIGHT_TALL=$(($WT_HEIGHT_TALL-7))

    WT_MB_HEIGHT=$WT_HEIGHT
    WT_MB_WIDTH=$WT_WIDTH
}


menu() {
       INTERFACE="gui"
    config_var_get_settings
    while true
    do
        whiptail_calc_wt_size
        MENU_CHOICE=$(whiptail --clear --backtitle "$BACKTITLE" --title "MAIN MENU" --ok-button "Select" --cancel-button "Exit" --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "LIST"      "   List media and image files" \
                "INFO"     "  " \
                "MOUNT"    "   Mount media" \
                "UNMOUNT"   "   " \
                "  "        "   " \
                "FirstAid"  "  "\
                "Format"  "   Erase" \
                "SETTINGS"  "   Change settings" \
                "TOOLS"     "   Various tools"\
                 "  "        "   " \
                 "HELP"     "   Help"\
                3>&1 1>&2 2>&3)
 
        whiptail_calc_wt_size        
        case $MENU_CHOICE in
            BACKUP)         media_backup  ;;
            
            RESTORE)        media_restore ;;
            
            LIST)           echo "Getting list of images ready..."
                            ui_msg LIST "$(do_list_info $DEFAULT_PATH)"  ;;
            
            SETTINGS)       menu_settings    ;;
            
            TOOLS)          menu_tools       ;;
            
            HELP)           ui_msg HELP "$(pisafe_help)" ;;
            
            ABOUT)          ui_msg ABOUT "$(pisafe_about)"  ;;     
             
            "  "*)          ;;
            
            * )             return       ;;
        esac
    done
    
}

#media_device_fullname
CMD=$1  
TARGET=$(media_device_fullname $2)
#SPECS=$3

#TARGET=$2

#echo_blue print inputs
#echo_blue $1
#echo_blue $2
#echo_blue $TARGET
#exit


INSTALL=$(env_installer)


case $CMD in
    -v)
        echo $VER
        exit
        ;;
        
    -h|help)
        disk_utility_help
        exit
        ;;
        
    list)
        run_command "lsblk $(media_device_name $2) -o name,type,size,pttype,fstype,label,fsuse%,mountpoint" $LINENO
        ;;        

    info*)      
        if [[ -z $2 ]]; then
            echo "Usage: diskutil info [disk | partition]"
            exit
        fi    
      
        if [[ $(media_device_type $2) = disk ]]; then
            media_disk_info $TARGET
        else
          #  media_disk_info $TARGET
          #  echo
            media_partition_info $TARGET 
        fi
        ;;
    
    listFilesystems)        echo "Supported file systems: $FILESYSTEMS "    ;;

    umount|unmount)         media_filesystem_unmount $TARGET  ;;  
    umountDisk|unmountDisk) media_disk_unmount $TARGET ;;
    eject)                  media_disk_eject $TARGET;;
    mount)              media_filesystem_mount $TARGET  ;;      
    mountDisk)          media_disk_mount $TARGET;;

    rename|renameFilesystem)    media_filesystem_rename $2 $3 ;;
    
    verify)       media_filesystem_check $TARGET  $3;;
    repair)       media_filesystem_repair $TARGET $3;;
    verifyDisk)         media_disk_verify $TARGET $3;; 
    repairDisk)         media_disk_repair $TARGET $3;; 
    
    eraseDisk)          media_disk_format $2 $3 $4 $5;;
    erasePartition)     media_partition_format $2 $3 $4 $5;;
    reformat)           media_partition_reformat $2 $3;;
    
    zeroDisk)           media_disk_wipe $2 zero $3 $4;;    #shred or dd or 
    randomDisk)         media_disk_wipe $TARGET random  ;;
    secureErase)        media_disk_wipe $TARGET shred  ;;
    
    createPartitionTable)   media_disk_createpartitiontable $2 $3 $4  ;;
    addPartition)           media_disk_addpartition $2 $3 $4 $5 $6 ;;
    delPartition)           media_disk_delpartition $2 $3 $4 $5 $6 ;;
    resize)                 media_partition_resize $2 $3 $4 ;;
    resizePartition)        media_partition_resize $2 $3 $4 ;;
    resizeFilesystem)       media_filesystem_resize $2 $3 $4 ;;
            
    clone)
        SOURCE=$1
        TARGET=$2
        media_clone $SOURCE $TARGET 
        ;;
    
        
    test)           media_test $TARGET ;;
        
    settings)       nano $SETTINGS ;;
    
    log)            nano $LOG_FILE ;;    
     
    menu)           menu ;; 
                
    *)
        disk_utility_help
        #error $LINENO "Command '$CMD' not recognized"
        #exit
        ;;
            
esac


