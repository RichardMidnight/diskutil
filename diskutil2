#!/bin/bash

# use shake to defrag


#defrag  app = shake
#fsck /dev/sda1

SCRIPTNAME="${0##*/}"
PRODUCTNAME=$SCRIPTNAME
VER="0.1.0"
BACKTITLE="Disk Utility"

SETTINGS="/home/$USER/.config/$SCRIPTNAME/$SCRIPTNAME.conf"
LOG_FILE="/home/$USER/.config/$SCRIPTNAME/$SCRIPTNAME.log"
LOG=on

FILESYSTEMS="fat16 fat32 exfat ntfs ext2 ext3 ext4"

WHITE='\033[1;37m'
RED='\033[1;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
LTBLUE='\033[1;34m'

NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }
echo_green()        { (echo -e "${GREEN}$*${NC}") }
echo_blue()         { (echo -e "${LTBLUE}$*${NC}") }    

ERRORS=0
INTERFACE=cli

PARTITION=$1
DEVICE=
PARTNUM=

PART_TYPE=   # primary / logical
PART_START=
PART_END=
PART_SIZE=
PART_MAX=

FILESYSTEM=
FS_SIZE=
FS_MIN=

BUFFER=$((10*1024*1024))  # 10 meg
NEW_SIZE=
NEW_END=




        


disk_utility_help(){
echo "Disk Utility Tool
Utility to manage disks and partitions
Based on Apple's diskutil
Most commands require an administrator or root user
WARNING: Most destructive operations are not prompted

This simplifies the use of: parted,  lsblk, udisksctl mount, udisksctl unmount, udisksctl power-off, 

Usage:  diskutil [quiet] <verb> <options>, where <verb> is as follows:

     list                 (List the partitions of a disk)
     info[rmation]        (Get information on a specific disk or partition)
     listFilesystems      (List file systems available for formatting)

     u[n]mount            (Unmount a single filesystem)
     unmountDisk          (Unmount an entire disk (all filesystems))
     eject                (Eject a disk)
     mount                (Mount a single filesystem)
     mountDisk            (Mount an entire disk (all mountable filesystems))

     X enableJournal        (Enable HFS+ journaling on a mounted HFS+ volume)
     X disableJournal       (Disable HFS+ journaling on a mounted HFS+ volume)
     X moveJournal          (Move the HFS+ journal onto another volume)
     X enableOwnership      (Exact on-disk User/Group IDs on a mounted volume)
     X disableOwnership     (Ignore on-disk User/Group IDs on a mounted volume)

     rename[Filesystem]   (Rename a filesystem)

     verify               (Verify the file system data structures of a filesystem)
     repair               (Repair the file system data structures of a filesystem)
     verifyDisk           (Verify the components of a partition map of a disk)
     repairDisk           (Repair the components of a partition map of a disk)
     X resetFusion        (Reset the components of a machines Fusion Drive)

     eraseDisk            (Erase an existing disk, removing all partitions and data)
     erasePartition       (Erase an existing partition)
     reformat             (Erase an existing filesystem with same name and type)
     X eraseOptical         (Erase optical media (CD/RW, DVD/RW, etc.))
     
     zeroDisk             (Erase a disk, writing zeros to the media)
     randomDisk           (Erase a disk, writing random data to the media)
     secureErase          (Securely erase a disk)

     createPartitionTable   (Erase the partition table and create a new one)
     X partitionDisk        ((re)Partition a disk, removing all volumes)
     addPartition         (Create a new partition to occupy free space)
     delPartition         (Delete a partition)
     X splitPartition       (Split an existing partition into two or more)
     X mergePartitions      (Combine two or more existing partitions into one)
     resizePartition      (Resize a partition and filesystem, increasing or decreasing its size)
     
     hexedit            (edit disk or partition)

     X appleRAID <verb>     (Perform additional verbs related to AppleRAID)
     X coreStorage <verb>   (Perform additional verbs related to CoreStorage)
     X apfs <verb>          (Perform additional verbs related to APFS)

diskutil <verb> with no options will provide help on that verb
"
}


run_command(){
    local CMD=$1
    local LINE=$2
    local QUIET=${3:-n}
    
    echo -n "- Running: "
    ui_echo "$CMD" blue
    eval $CMD
    ES=$?
    if (( $ES )); then
        #ui_msg_error $LINENO "Error $RC running '$CMD'"
        ui_echo "~ Exit_status $ES running '$CMD'" red log
        return $RC
    fi
}


file_path(){
    dirname "$*"
}

function info() {
	echo "$SCRIPTNAME: $1 ..."
}


function error() {
	echo -n "$SCRIPTNAME: ERROR occured in line $1: "
	shift
	echo_red "$@"
}


env_installer(){
    local INSTALLER=

    if [ -f /usr/bin/apt ]; then             # debian
        INSTALLER="apt install -y"
    elif [ -f /usr/bin/pacman ]; then        # arch
        INSTALLER="pacman -S --noconfirm"
    elif [ -f /usr/bin/dnf ]; then            #rpm / fedora
        INSTALLER="dnf install -y"  
    fi

    echo "$INSTALLER"
}


env_install_tools() {   
    TOOL_MISSING=false
    TOOLS=$(parted )
    INSTALL=$(env_installer)
    
    for TOOL in $TOOLS ; do
        #if [ ! $(which $TOOL) ]; then
        if [ ! -f /usr/bin/$TOOL ]  && [ ! -f /usr/local/bin/$TOOL ] ; then
            TOOL_MISSING=true
        fi
    done
    
    if [ $TOOL_MISSING = "true" ]; then
        echo "Installing required tools ($REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL)"
        RESULT=y
        if [ $RESULT != "y" ]; then
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
            return 1
        fi

        for TOOL in $REQUIRED_TOOLS ; do
             if [ ! -f /usr/bin/$TOOL ]; then
                echo_white Installing $TOOL ...
                sudo $INSTALL $TOOL
                EXIT_CODE=$?
                if [ $EXIT_CODE != 0 ]; then
                    ui_msg "Error" "$TOOL not installed." "red"
                fi
            fi
        done
        
        # Special installs ...
        
        # Install PiShrink
        if [ ! -f /usr/local/bin/pishrink.sh ]; then
            echo_white Installing pishrink...
            wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
            sudo chmod +x pishrink.sh
            sudo mv pishrink.sh /usr/local/bin
            if [ ! -f /usr/local/bin/pishrink.sh ] ; then
              ui_msg "Error" "pishrink not installed." "red" 
            else
              ui_msg  pishrink installed.
            fi
        fi

        # Install xz
        if [ ! -f /usr/bin/xz ]; then
            echo_white Installing xz-utils...
            sudo $INSTALL xz-utils
            if [ ! -f /usr/bin/xz ]; then
               ui_msg "Error" "xz not installed." "red" 
            fi
        fi
    
    fi
}    


env_install_smarttools(){
    # https://www.addictivetips.com/ubuntu-linux-tips/check-hard-drive-health-on-linux/
    
#Ubuntu
sudo apt install smartmontools
#Debian
sudo apt-get install smartmontools
#Arch Linux
sudo pacman -S smartmontools
#Fedora
sudo dnf install smartmontools
#OpenSUSE
sudo zypper install smartmontools
    
}


# ---------- Misc functions

do_beep(){
    FREQ=${1:-600}
    TIME=${2:-.5}
    
    if [[ $SOUND = on ]] ; then
        (speaker-test -t sign -f $FREQ > /dev/null & sleep $TIME && kill -9 $! ) > /dev/null
      #  sleep .5  # to allow the beep to end
    fi
}


do_beep_up(){
    do_beep 500 .3
    do_beep 600 .6
}


do_beep_down(){
   do_beep 600 .3
   do_beep 500 .6
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


do_countdown(){  
    local MAX=${1:-10}
    local MSG=${2:-"Pausing for $MAX seconds... Press y to continue immediately or any other key to stop"}
 
   # echo "Pausing for $MAX seconds... Press y to continue immediately or any other key to stop"
    echo "$MSG"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
        read -s -t 1 -N 1 INPUT
        if [[ ! -z $INPUT ]]; then
            if [[ $INPUT = y ]]; then
                echo Continuing...
                return
            else
                echo " $INPUT Stopping countdown..."
                return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
    echo ...
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
    
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


get_bytes(){
    # translates from bytes to human readable and vice-verse
    # currently shows 3 significant digits.
    local BYTES=$1
    local OUTPUT=${2:-"-h"};  #human or bytes
    
    local BASE=$(echo $BYTES | tr -cd '[[:digit:]]' )
    local SUFFIX=$(echo $BYTES | tr -cd '[[kmgtbKMGTB]]' )

    if ! [[ $BASE =~ ^[0-9]+$ ]] ; then   # not a number   
        ui_msg_warning $LINENO "$BASE not a number"
        return 0
    fi
    
    # if no translation needed... then just echo the input and leave
    if [[ $OUTPUT != -h ]] && [[ -z $SUFFIX ]] ; then
        echo $BYTES
        return
    fi
    
    if [[ $OUTPUT = -h ]] && [[ ! -z $SUFFIX ]] ; then
        echo $BYTES
        return
    fi

    if [[ $OUTPUT = -h ]] ; then  # translate to human readable
    
        if [[ -z $SUFFIX ]]; then
            local LEN=${#BYTES}
            local k_ilo=1024;
            local m_ega=$k_ilo*$k_ilo;
            local g_iga=$m_ega*$k_ilo;
            local t_era=$g_iga*$k_ilo;
            local p_eta=$t_era*$k_ilo;
            
            [[ -z $BYTES ]] && return               # null, so exit
            
            if ! [[ $BYTES =~ ^[0-9]+$ ]] ; then    # not a number   
                echo 0
                return 1
            fi
            
            case $LEN in
                4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
                5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
                6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
                
                7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
                8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
                9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
                
                10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
                11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
                12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
                
                13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
                14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
                15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
                *)  echo $BYTES ;;
            esac
        else
            echo $BYTES
        fi    
    else  # translate to bytes
        case $SUFFIX in
        b|B|"")     echo $BASE ;;
        k|K|kb|KB)  echo $(($BASE*1024)) ;;
        m|M|mb|MB)  echo $(($BASE*1024*1024)) ;;
        g|G|gb|GB)  echo $(($BASE*1024*1024*1024)) ;;
        t|T|tb|TB)  echo $(($BASE*1024*1024*1024*2014)) ;;
        *)          ui_msg_error $LINENO "bad byte suffix 'SUFFIX'"  ;;
        esac
    fi
}


device_fullname(){
    DEVICE=$1
    
    if [[ -z $DEVICE ]]; then
        return
    fi
    
    
    if [[ ${DEVICE:0:5} != "/dev/" ]]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        #INDEV="/dev/"$INDEV
        echo "/dev/$DEVICE"
    else
        echo "$DEVICE"
    fi
}


env_root_device() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    # new simpler way
    ROOT_PARTITION=$(findmnt -no source /)
    ROOT_MAJ=$(findmnt  -n -e  -o MAJ:MIN / | cut -d: -f1)
    ROOT_DEV=$(lsblk | grep $ROOT_MAJ:0 | cut -d" " -f1)
    echo $ROOT_DEV
}

 
env_which () {
    #fixes manjaro's which command 
    local FILE=$1
    
    # if which not installed, try to install it
    which which 1>/dev/null 2>/dev/null
    if (( $? )); then
        sudo apt install which -y
        sudo pacman -S which --noconfirm
        sudo dnf install which -y
    fi
    
    which $FILE 1>/dev/null 2>/dev/null
    if (( $? )); then
        #echo false
        return 1
    else
        echo 1
        return 0
    fi       
}


is_number(){
    NUM=$1
    
    # trim NUM
    NUM=$(echo $NUM | sed 's/ //g')
    
    case $NUM in
        ''|*[!0-9]*) 
            echo false
            return 1
            ;;
        *) 
            echo true
            return 0
            ;;
    esac
}

###
info_validate_num(){
    local VAR=$1
    local NUM=$2
   # local LINE=$3
    local MIN=$3
    local MAX=$4

   
    if ! $(is_number "$NUM"); then 
        ((ERRORS++))
        error $LINENO "Variable '$VAR' '$NUM' not a number"
        return 1
    fi
    
 
    if (( $MIN )); then
        if [ "$NUM" -lt "$MIN" ]; then
            ((ERRORS++))
            error $LINENO "Variable '$VAR' '$NUM' ($(bytes $NUM) too small ('$MIN' '$MAX')"
        fi
    fi
    
    
    if (( $MAX )); then
        if [ $NUM -gt $MAX ]; then
            ((ERRORS++))
            error $LINENO "Variable '$VAR' '$NUM' too big"
        fi
    fi
}


info_validate(){
    echo_white Validating data...
    
    # info_validate_num variable num min max
    
    #echo Errors start=$ERRORS
    local DEVICE_MIN=$((10*1025*1024))          # 10mb
    local DEVICE_MAX=$((1024*1024*1024*1024))   # 1TB
    local PART_MIN=$((10*1024*1024))
    
    
    # confirm we got good partition numgers
    info_validate_num PARTNUM $PARTNUM 1 20
    info_validate_num DEVICE_SIZE $DEVICE_SIZE $DEVICE_MIN $DEVICE_MAX
    info_validate_num BUFFER $BUFFER
    
    info_validate_num PART_START $PART_START 512 $DEVICE_MAX
    info_validate_num PART_END $PART_END $PART_START $DEVICE_MAX
    info_validate_num PART_SIZE $PART_SIZE $PART_MIN $DEVICE_MAX
    info_validate_num PART_MAX $PART_MAX  $PART_MIN $DEVICE_MAX 
    
    # confirm we got good filesystem numgers
    info_validate_num FS_SIZE $FS_SIZE $(( $PART_SIZE-$((5*1024*1024)) ))  $PART_SIZE
    info_validate_num FS_MIN $FS_MIN $PART_MIN $PART_SIZE
    
    info_validate_num MIN_SIZE $MIN_SIZE
    info_validate_num MIN_END $MIN_END
    info_validate_num MAX_SIZE $MAX_SIZE
    info_validate_num MAX_END $MAX_END
    
    
    if $(is_number "$SIZE"); then
        #echo validateing size
        info_validate_num SIZE $SIZE $MIN_SIZE $MAX_SIZE
    fi
    
     
    if (( $ERRORS )); then
        error $LINENO "$ERRORS Errors found in validating data. Recommend running '$SCRIPTNAME $PARTITION fix'."
        return 1
    else
        echo_green info_validate OK
    fi    
    
}


do_countdown(){  
    local MAX=${1:-10}
 
    echo "Pausing for $MAX seconds... Ctrl-C to stop, y to continue immediately"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
        read -t 1 -N 1 INPUT
        if [ ! -z $INPUT ]; then
            if [ $INPUT = "y" ]; then
                echo continuing...
                return 0
            else
                echo $INPUT
                return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
    echo ...
}


# ---------- UI functions
ui_countdown(){
    local SECONDS=${1:-10}
    local TITLE="${2:-Countdown}"
    #local MESSAGE="${3:-Counting down...}"
    local MESSAGE=${3:-"Pausing for $SECONDS seconds... Press y to continue immediately or any other key to stop"}
    
    if [[ $INTERFACE = cli ]]; then
        do_countdown $SECONDS "$MESSAGE"
    else
        whiptail_countdown "$SECONDS" "$TITLE" "$MESSAGE"
    fi
}


ui_echo(){
    # used to notify on the terminal what is going on.  optionally log it.
    # ui_echo "msg" red log
    MSG="$1"
    COLOR="${2:-grey}"
    local LOGIT="${3:-log}"   # or nolog
    
    if [[ $LOGIT = log ]]; then    
        ui_log "$MSG"  
    fi
    
    case $COLOR in
        red)        echo_red "$MSG" ;;
        white)      echo_white "$MSG" ;;
        blue)       echo_blue "$MSG" ;;
        green)      echo_green "$MSG" ;;
        *)          echo -e "$MSG" ;;
    esac
}


ui_log(){
    # usage ui_log "message"
    INFO=$*
    
    INFO=$(echo $INFO | sed 's/\\n/ -/g')  #change newline for ~
    
    if [[ ! -d $(file_path $LOG_FILE) ]]; then
        mkdir -p $(file_path $LOG_FILE)
    fi
    
    if [[ $LOG = on ]]; then
        touch $LOG_FILE
        echo "$(date "+%Y-%m-%d %H:%M") $INFO" >> $LOG_FILE
    fi
}


ui_msg() {
    #general message function.  Supports CLI whiptail and logging.
    # usage ui_msg INSTALL "$MSG" white OK log
    TITLE="$1"
    MSG="${2:-no message}"
    COLOR="${3:-grey}"
   # OK_BUTTON="${4:-Back}"
    OK_BUTTON="${4:-OK}"
    local LOGIT="${5:-no}"   # or log
    
    if [[ $LOGIT = log ]]; then
        ui_log "$MSG"
    fi    
    
    if [[ $INTERFACE = cli ]]; then
        ui_echo "$TITLE: $MSG" $COLOR nolog 
    else
        whiptail --backtitle "$BACKTITLE" --title "$TITLE" --scrolltext --ok-button "$OK_BUTTON" --msgbox "$MSG" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
    fi
}


ui_msg_error() {
    # usage:  ui_msg_error $LINENO "message"
    LINE=$1
    shift
    do_beep_down
    MSG="$@"
    ui_msg ERROR "~ Error at line $LINE. $MSG" red "" log
}


ui_msg_warning(){
    # usage:  ui_msg_warning $LINENO "message"
    LINE=$1
    shift
    do_beep
    do_beep
    MSG="$@"
    ui_msg WARNING "~ $MSG" red "" nolog
}



ui_yesno(){
    # general yes/no function.  Supports CLI and whiptail.
    # note, this output is often assigned to a variable, so don't add any additional echo statements.
    TITLE="$1"
    MSG="$2"
    DEFAULT="${3:-""}"   # defaults to Yes.  can specify --defaultno
   # COLOR="${4:-white}"  color does not work with the 'read' command
    
    if [[ $INTERFACE = cli ]]; then
        MSG="$PRODUCTNAME: $TITLE: $MSG  [y/n]?"
        # change 'newline' chars to ' -'
        MSG=$(echo $MSG | sed 's/\\n/ -/g')
        while true; do        
            read -s -n1 -p "$MSG" yn
            case $yn in
                [Yy]* ) echo y; return 0;;
                [Nn]* ) echo n; return 0;;
                * )     ;;
            esac
        done
    else    
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" $DEFAULT --yesno "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH 3>&1 1>&2 2>&3
        RC=$?
        if (( $RC )); then
            echo n
        else
            echo y
        fi
        return $RC
    fi
}


    # trim NUM
#    NUM=$(echo $NUM | sed 's/ //g')
    
#    case $NUM in
#        ''|*[!0-9]*) 


bytes(){
    # translates from bytes to human readable and vice-verse
    # currently shows 3 significant digits.
    local BYTES=$1
    local OUTPUT=${2:-"-h"};  #human or bytes
    
    local BASE=$(echo $BYTES | tr -cd '[[:digit:]]' )
    local SUFFIX=$(echo $BYTES | tr -cd '[[kmgtbKMGTB]]' )

    if ! $(is_number $BASE); then
        return 1
    fi

    # if no translation needed... then just echo the input and leave
    if [ $OUTPUT != "-h" ] && [ -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi
    
     if [ $OUTPUT = "-h" ] && [ ! -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi



    if [ $OUTPUT = "-h" ] ; then  # translate to human readable
    
        if [ -z $SUFFIX ]; then
            local LEN=${#BYTES}
            local k_ilo=1024;
            local m_ega=$k_ilo*$k_ilo;
            local g_iga=$m_ega*$k_ilo;
            local t_era=$g_iga*$k_ilo;
            local p_eta=$t_era*$k_ilo;
            
            [ -z "$BYTES" ] && return
            
            NUM='^[0-9]+$'
            if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number   
                return 1
            fi
            
            case $LEN in
                4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
                5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
                6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
                
                7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
                8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
                9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
                
                10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
                11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
                12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
                
                13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
                14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
                15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
                *)  echo $BYTES ;;
            esac
        else
            echo $BYTES
        fi    

    else  # translate to bytes
    
        case $SUFFIX in

        b|B|"")
            echo $BASE
            ;;
        
        k|K|kb|KB)
            echo $(($BASE*1024))
            ;;

        m|M|mb|MB)
            echo $(($BASE*1024*1024))
            ;;
            
        g|G|gb|GB)
            echo $(($BASE*1024*1024*1024))
            ;;
            
        t|T|tb|TB)
            echo $(($BASE*1024*1024*1024*2014))
            ;;
        *)
            error Error $LINENO
            ;;
    
        esac
    fi
}


get_bytesXX(){
    # translates from bytes to human readable and vice-verse
    # currently shows 3 significant digits.
    local BYTES=$1
    local OUTPUT=${2:-"-h"};  #human or bytes
    
    local BASE=$(echo $BYTES | tr -cd '[[:digit:]]' )
    local SUFFIX=$(echo $BYTES | tr -cd '[[kmgtbKMGTB]]' )

    
    NUM='^[0-9]+$'
    if ! [[ $BYTES =~ $NUM ]] ; then   # not a number   
        return 1
    fi
    

    # if no translation needed... then just echo the input and leave
    if [[ $OUTPUT != "-h" ]] && [[ -z $SUFFIX ]] ; then
        echo $BYTES
        return
    fi
    
    if [[ $OUTPUT = "-h" ]] && [[ ! -z $SUFFIX ]] ; then
        echo $BYTES
        return
    fi


    if [[ $OUTPUT = "-h" ]] ; then  # translate to human readable
    
        if [[ -z $SUFFIX ]]; then
            local LEN=${#BYTES}
            local k_ilo=1024;
            local m_ega=$k_ilo*$k_ilo;
            local g_iga=$m_ega*$k_ilo;
            local t_era=$g_iga*$k_ilo;
            local p_eta=$t_era*$k_ilo;
            
            [[ -z $BYTES ]] && return
            
            NUM='^[0-9]+$'
            if ! [[ $BYTES =~ $NUM ]] ; then   # not a number   
                return 1
            fi
            
            case $LEN in
                4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
                5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
                6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
                
                7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
                8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
                9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
                
                10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
                11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
                12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
                
                13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
                14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
                15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
                *)  echo $BYTES ;;
            esac
        else
            echo $BYTES
        fi    

    else  # translate to bytes
    
        case $SUFFIX in

        b|B|"")
            echo $BASE
            ;;
        
        k|K|kb|KB)
            echo $(($BASE*1024))
            ;;

        m|M|mb|MB)
            echo $(($BASE*1024*1024))
            ;;
            
        g|G|gb|GB)
            echo $(($BASE*1024*1024*1024))
            ;;
            
        t|T|tb|TB)
            echo $(($BASE*1024*1024*1024*2014))
            ;;
        *)
            ui_error $LINENO "bad byte suffix 'SUFFIX'"
            ;;
    
        esac
    fi
}




info_get(){
    PARTITION=$1
    local WAS_MOUNTED

    #Gather info
    echo_white "Gathering partition info..."
    
   # if [ ! -e "$PARTITION" ]; then
   #     ((ERRORS++))
   #     error $LINENO "Partition '$PARTITION' does not exist"
   #     return 1
   # fi
    
    # get device name
    DEVICE=$(media_device_devicename $PARTITION)
    if (( $? )); then
        return 1
    fi       
    #if [ -z "$(echo $PARTITION | grep p)" ] ;then
    #    DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    #else
    #    DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    #fi
    
    # get partition number
    PARTNUM=$(media_device_partnum $PARTITION)
    if (( $? )); then
        return 1
    fi   
    #PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')
    
    #if [ ! -e "$DEVICE" ]; then
    #    error $LINENO "Device '$DEVICE' does not exist"
    #    return 1
    #fi 

    #if [ ! -e "$DEVICE$PARTNUM" ]; then
    #    error $LINENO "PARTITION '$DEVICE$PARTNUM' does not exist"
    #    return 1
    #fi 
    
    PARTITION=$DEVICE$PARTNUM
    media_device_checktarget $PARTITION part
    if (( $? )); then
        return 1
    fi    


    # get partition info
    parted_output="$(sudo parted -ms "$DEVICE" unit B print)"
    rc=$?
    if (( $rc )); then
        error $LINENO "parted failed with rc $rc"
        error $LINENO "Possibly invalid image. Run 'parted $MEDIA unit B print' manually to investigate"
        return 6
    fi
    parted_free_output="$(sudo parted -ms "$DEVICE" unit B print free)"
    DEVICE_SIZE="$(echo "$parted_output" | grep $DEVICE | cut -d ':' -f 2 | tr -d 'B')"
    PART_TABLE="$(echo "$parted_output" | grep $DEVICE | cut -d ':' -f 6 | tr -d 'B')"
    PART_START="$(echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 2 | tr -d 'B')"
    PART_END="$(echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 3 | tr -d 'B')"
    PART_SIZE="$(echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 4 | tr -d 'B')"
    if [ -z "$(sudo parted -s "$DEVICE" unit B print | grep "$PART_START" | grep logical)" ]; then
        PART_TYPE="primary"
    else
        PART_TYPE="logical"
    fi
    FILESYSTEM="$(echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 5 )"
    PART_FREE="$(echo "$parted_free_output" | grep $PART_START -A 1 | grep -v  $PART_START | grep free | cut -d ':' -f 3 | tr -d 'B')"
    if [ -z $PART_FREE ]; then
        PART_MAX=$PART_END
    else
        PART_MAX=$PART_FREE
    fi
    
    
    echo_green partition_info OK
    
    # unmount if needed
    if [ ! -z "$(df | grep ^$PARTITION)" ]; then
        echo "Unmounting $PARTITION ..."
        WAS_MOUNTED=true
        umount $PARTITION
    fi
    
    
    #check filesystem
    echo_white Check filesystem ...
    media_filesystem_check $PARTITION
    rc=$?   
    if (( $rc )); then
        error $LINENO "Error checking file system"
        #return 1
    #else
    #    echo_green Filesystem OK
    fi

    
    # get filesystem info
    echo_white "Getting '$FILESYSTEM' filesystem info..."
    # get filesystem info
    case $FILESYSTEM in
    
        ext4)
            tune2fs_output="$(sudo tune2fs -l "$PARTITION")"
            rc=$?
            if (( $rc )); then
                echo "$tune2fs_output"
                error $LINENO "tune2fs failed. Unable to shrink this type of image"
                return 7
            fi

            currentsize="$(echo "$tune2fs_output" | grep '^Block count:' | tr -d ' ' | cut -d ':' -f 2)"
            blocksize="$(echo "$tune2fs_output" | grep '^Block size:' | tr -d ' ' | cut -d ':' -f 2)"
 
            sudo e2fsck -fy "$PARTITION"
            minsize=$(sudo resize2fs -P "$PARTITION" | grep minimum | cut -d: -f2 | sed 's/ //g')

            if ! (( $minsize )); then
                minsize=0
            fi

            #FS_SIZE_BLOCKS=$minsize
            if [[ $(is_number $currentsize) ]] && [[ $(is_number $blocksize) ]]; then
                FS_SIZE=$(($currentsize * $blocksize))
            fi
      
            
            if [ $(is_number "$minsize") ] && [ $(is_number "$blocksize") ]; then
                #FS_MIN=$(( $(($minsize * $blocksize)) + $BUFFER ))
                FS_MIN=$(($minsize * $blocksize))
            fi
            ;;
            
        fat32)
             FS_SIZE=$(sudo fsck.exfat  "$PARTITION" | grep Size: | cut -d : -f2 | sed 's/ //g')
              FS_MIN=$(sudo fatresize  "$PARTITION" | grep Min | cut -d : -f2 | sed 's/ //g')
        #    FS_SIZE=$(sudo fatresize -i "$PARTITION" | grep Volume | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
 
 
         #   FS_MIN=$(sudo fatresize -i "$PARTITION" | grep Used | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
        #    if [ $(is_number $PART_START) ] && [ $(is_number $FS_SIZE) ]; then
        #        FS_END=$(($PART_START + $FS_SIZE))
        #    fi

        
            ;;
            
        exfat)
            FS_SIZE=$(sudo fsck.exfat  "$PARTITION" | grep Volume | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
            FS_MIN=$(sudo fsck.exfat  "$PARTITION" | grep Used | sed 's/  */ /g' | cut -d' ' -f3-4 | sed 's/ //g')
            FS_SIZE=$(bytes $FS_SIZE -b)
            FS_MIN=$(bytes $FS_MIN -b)
            ;;     
            
            
        ntfs)
            sudo ntfsfix -d $PARTITION
            FS_SIZE=$(sudo ntfsresize -i "$PARTITION" | grep "Current volume size:" | cut -d : -f2 | cut -d "b" -f1 | sed 's/ //g')
            
            FS_MIN=$(sudo ntfsresize -i "$PARTITION" | grep "resize at" | cut -d t -f 3 | cut -d b -f1 | sed 's/ //g') 
         #   if [ $(is_number $PART_START) ] && [ $(is_number $FS_SIZE) ]; then
         #       FS_END=$(($PART_START + $FS_SIZE))
         #   fi
            ;;
            
            
        *)
            error $LNENO "fs not known"
                ;;
    esac
    
    if [ "$FS_MIN" = "" ]; then
        FS_MIN=0
    fi
    
    MIN_SIZE=$FS_MIN
  #  if (( is_number "$PART_START" )) && (( is_number "$FS_MIN" )); then
#echo OK
        MIN_END=$(($PART_START+$FS_MIN))
        
 #   fi
    MAX_END=$PART_MAX
   # if [ $(is_number $PART_MAX) = true ] && [ $(is_number $PART_START) = true ]; then
        MAX_SIZE=$(( $PART_MAX - $PART_START ))
        
   # fi    
   echo_green   filesystem_info OK
    
    
    
    # process size parameter
    case $SIZE in
    
        min)
            NEW_SIZE=$(($MIN_SIZE + $BUFFER))
            NEW_END=$(($PART_START + $NEW_SIZE ))
            ;;
            
        max)
            NEW_SIZE=$MAX_SIZE
            NEW_END=$MAX_END
            ;;
        
        *[0-9]*) 
            NEW_SIZE=$(bytes $SIZE -b)
            NEW_END=$(($PART_START + $NEW_SIZE))
            ;;
            
        fix)
            NEW_SIZE=$(($PART_SIZE - 1))    
            NEW_END=$(($PART_START + $NEW_SIZE - 1))      
            ;;
            
     #   info)
     #       ;;
            
         "")
      #          SIZE=1
                ;;
                
        *)
            error $LINENO "Invalid size '$SIZE'"
            return 1
            ;;
    esac

    
    
    if [ $WAS_MOUNTED ]; then
        echo Remounting $PARTITION ...
        sleep 2
        udisksctl mount -b  $PARTITION
        sleep 1
    fi
    
    echo_green  info_get OK
}


info_echo(){
    echo
    echo "=======   VARIABLES ============"
    echo "PARTITION    = '$PARTITION'"
    echo "DEVICE       = '$DEVICE'"
    echo "PARTNUM      = '$PARTNUM'"
    echo "Partition tbl= $PART_TABLE  "
    echo "PART_TYPE    = '$PART_TYPE'"
    echo "DEVICE_SIZE  = $(bytes $DEVICE_SIZE -h)      '$DEVICE_SIZE' "
    echo "BUFFER       = $(bytes $BUFFER -h)      '$BUFFER' "
    echo
    echo "PART_START   = $(bytes $PART_START -h)      '$PART_START' "
    echo "PART_END     = $(bytes $PART_END -h)      '$PART_END'  "
    echo_white "PART_SIZE    = $(bytes $PART_SIZE -h)      '$PART_SIZE'  $(($PART_SIZE/1024/1024))M  ($(($PART_SIZE-$PART_END+$PART_START)) b larger than calc)"
  #  echo "calc         = '$(($PART_END -$PART_START))'  ($(($PART_SIZE-$PART_END+$PART_START)) b smaller than size) "
    echo "PART_MAX     = $(bytes $PART_MAX -h)      '$PART_MAX'  "
    echo
    echo "FILESYSTEM   =" $FILESYSTEM

    if [ ! -z $FS_SIZE ]; then
        echo_white "FS_SIZE      = $(bytes $FS_SIZE -h)      '$FS_SIZE' $(($FS_SIZE/1024/1024))M  ($(($PART_SIZE-$FS_SIZE)) b smaller than partition)"
    else
        echo_white "FS_SIZE      = $(bytes $FS_SIZE -h) "
    fi

    
    echo "FS_MIN       = $(bytes $FS_MIN -h)      '$FS_MIN'    "  
   # echo "FS_END        = '$FS_END'"   
    #echo "DIFF          =" $(( PART_END - $FS_END ))
    #echo "Note: NTFS fs will be 3584 b smaller than partition"
    echo 
    echo "MIN_SIZE     = $(bytes $MIN_SIZE -h)      '$MIN_SIZE' "
    echo "MIN_END      = $(bytes $MIN_END -h)      '$MIN_END' "
    echo "MAX_SIZE     = $(bytes $MAX_SIZE -h)      '$MAX_SIZE' "
    echo "MAX_END      = $(bytes $MAX_END -h)      '$MAX_END' "
    echo
    if (( $SIZE )); then
        echo "SIZE         = '$SIZE'    $(($SIZE/1024/1024))M" 
    else
        echo "SIZE         = '$SIZE'"
    fi
    echo
    echo "NEW_SIZE     = $(bytes $NEW_SIZE -h)      '$NEW_SIZE' " 
    echo "NEW_END      = $(bytes $NEW_END -h)      '$NEW_END' "
    echo "==================="   
}


media_disk_createpartitiontable(){
    local PART_TABLE=$1   # msdos | gpt
    local DEVICE=$(device_fullname $2)
    local SILENT=$3
    
    if [[ -z $1 ]];then
        echo "Usage: diskutil createPartitionTable [msdos|gpt] device"
        return 1
    fi
    
    if [[ $PART_TABLE = "msdos" ]] || [[ $PART_TABLE == "gpt" ]] ; then
        x=1
    else
        echo unsupported partition table type: $PART_TABLE
        return 2
    fi
     
    
    media_check_target $DEVICE disk
    if (( $? )); then
        exit 1
    fi    
    
    if [[ -z $DEVICE ]] ; then
        ui_msg_error $LINENO "Device not specified."
        lsblk -dp
        return 1
    fi

    if [[ ! -e $DEVICE ]]; then
        ui_msg_error $LINENO "'$DEVICE' does not exist"
        return 2
    fi

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi

    
    # quit if is mounted
    if [[ ! -z "$(df | grep ^$DEVICE)" ]] ; then
        echo Error: $DEVICE is mounted
        echo Try diskutil unmountDisk $DEVICE
        df | grep ^$DEVICE
        return 1
    fi
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    
    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi
       
    echo "Writing zeros to '$DEVICE'..."
    run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

    echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
    run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO
    
}


media_disk_addpartition(){
    local FORMAT=$1    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=$2
    local SIZE=$3
    local DEVICE=$(device_fullname $4)
    local SILENT=$5   # -y
  
    if [[ -z $1 ]]; then
        echo "Usage: diskutil addPartition format name size device"
        echo "  Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4" | linux-swap
        echo Example: diskutil addPartition ntfs Untitled 2G /dev/disk3
        echo Example: diskutil addPartition exfat NEWDISK 3G sda
        return
    fi
    
    media_check_target "$DEVICE" disk 
    if (( $? )); then
        return 1
    fi 
    
    PART_TABLE=$(sudo parted $DEVICE print | grep "Partition Table" | cut -d: -f2 | sed 's/ //g')
    
    local ROOT="$(env_root_device)"
    local TYPE="$(lsblk $DEVICE -dnpo TYPE)"
   # local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE,TYPE) ($DEVICE)"
    local PARTITION=$DEVICE



	if [[ ${FORMAT:0:3} = fat ]] && [[ $PART_TABLE != "msdos" ]] ; then   
        echo incompatable Partition table $PART_TYPE
        return 1 
    elif  [[ ${FORMAT:0:3} != fat ]] && [[ $PART_TABLE != "gpt" ]]  ; then 
        echo incompatable Partition table $PART_TYPE
        return 1 
	fi


    if [[ ${FORMAT:0:3} = fat ]] ; then   
		PART_TABLE=msdos
		PART_TYPE=primary
		PART_NAME=
	else
		PART_TABLE=gpt
		PART_TYPE=
		PART_NAME=PART  
	fi


	if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi
	
    
    # get start location
    #LAST+PARTITION=
    parted_output="$(sudo parted -ms "$DEVICE" unit B print)"
    device_size="$(echo "$parted_output" | grep $DEVICE | cut -d ':' -f 2 | tr -d 'B')"
    partnum="$(echo "$parted_output" | tail -n 1 | grep -v $DEVICE | cut -d ':' -f 1)"
    partstart="$(echo "$parted_output" | tail -n 1 | grep -v $DEVICE | cut -d ':' -f 2 | tr -d 'B')"
    partend="$(echo "$parted_output" | tail -n 1 | grep -v $DEVICE | cut -d ':' -f 3 | tr -d 'B')"
    

    # if no partitions present
    if [[ $(is_number $partnum) = false ]]; then
        #echo no partitions found
        partnum=0
        partstart=0
        partend=0
        BUFFER=$((1024*1024))
    else
        BUFFER=1
    fi    

    # limit size to 4G if fat16    
    if [[ $FS_TYPE = fat16 ]] && [[ $(media_size $DEVICE) -gt $(get_bytes 4G) ]]; then
        SIZE=4G
    fi   
    
    
echo EXISTING
echo device_size=$device_size
echo partnum=$partnum
echo partstart=$partstart
echo partend=$partend
echo buffer=$BUFFER    

echo SIZE=$SIZE


    NEW_PARTITION=$DEVICE$(($partnum+1))
    BEG=$(($partend+$BUFFER))
    
    if [[ "$SIZE" == *"%"* ]]; then
       # SIZE="$(echo $SIZE | tr -d '%')"
       # SIZE=$(($device_size/100*$SIZE))
       END=$SIZE
    else   
        END=$(( $BEG+$(get_bytes $SIZE -b) ))
        END=$END\B
    fi

    BEG=$BEG\B


echo
echo NEW
echo newPart=$NEW_PARTITION
echo new_beg=$BEG
echo new_size=$SIZE
echo new_end=$END

    if [[ -z $DEVICE ]] ; then
        ui_msg_error $LINENO "Device not specified."
        lsblk -dp
        return 1
    fi

    if [[ ! -e $DEVICE ]]; then
        ui_msg_error $LINENO "'$DEVICE' does not exist"
        return 2
    fi

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi
    
    # Stop if dev is the root device
    if [[ $DEVICE = $(env_root_device) ]]; then
        ui_msg_error $LINENO "Format root device not allowed"
        return 3
    fi

    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi

       echo "Creating partition on '$DEVICE'..."
     #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
        run_command "sudo parted -s -a opt $DEVICE mkpart $PART_TYPE '$PART_NAME' $FS_TYPE $BEG $END" $LINENO
        

    sleep 2
    echo "Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat16) 
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -F16 -v -I -n '$NAME' $NEW_PARTITION" $LINENO
            ES=$?
            ;;

        fat32)
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -v -I -n '$NAME' $NEW_PARTITION" $LINENO
            ES=$?
            ;;
            
        exfat)
            #https://unix.stackexchange.com/questions/61209/create-and-format-exfat-partition-from-linux
            if [[ -z $(which mkfs.exfat) ]] ; then
                echo Installing exfat support ...
                sudo $INSTALL exfat-utils 
                sudo $INSTALL exfat-fuse 
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi    
            run_command "sudo mkfs.exfat -n '$NAME' $NEW_PARTITION" $LINENO
            ES=$?
            ;;      
        
        ntfs)
            if [[ -z $(which mkfs.ntfs) ]] ; then
                #sudo apt-get install fuse ntfs-3g
                echo Installing ntfs support...
                sudo $INSTALL fuse 
                sudo $INSTALL ntfs-3g 
                sudo $INSTALL ntfsprogs  #ntfsprogs is for arch
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi  
            run_command "sudo mkfs.ntfs -f -L '$NAME' $NEW_PARTITION" $LINENO
            ES=$?
            ;;
        
        ext2 | ext3 | ext4)
            run_command "sudo mkfs -t $FORMAT -L '$NAME' -E root_owner=$UID:$GID -F $NEW_PARTITION" $LINENO
            ES=$?
            ;;
            
        linux-swap)
            run_command "sudo mkswap -L '' $NEW_PARTITION" $LINENO
             ES=$?
            ;;
            
        *)
            ui_msg_error $LINENO "Unknown format '$FORMAT'"
            
    esac

    if (( $ES)); then
        return 1
    else
        ui_msg "ERASE MEDIA" "~ Format complete. '$(media_name $DEVICE)' has been erased." white "" log
    fi
    
}


media_disk_partition_table(){
    local DEVICE=$1
    
    DISK=$(echo $DEVICE | sed 's/[0-9]*$//')
    
    echo $(sudo parted -m $DISK print | grep $DISK | cut -d: -f6)
    
}


media_filesystem_mount(){
    local TARGET=$(device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil mount partition"
        return
    fi
    
    media_check_target $TARGET part
    if (( $? )); then
        exit 1
    fi
    run_command "udisksctl mount -b $TARGET" $LINENO 2>/dev/null
}
        
        
media_disk_mount(){
    local TARGET=$(device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil mountDisk device"
        echo "Attempts to mount all filesystems on device"
        return
    fi
    
    media_check_target $TARGET disk
    if (( $? )); then
        exit 1
    fi
   
    PARTITION_COUNT=$(media_partition_count $TARGET)
 #  for ((i = 0 ; i <= 1000 ; i++)); do
    
    for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
        run_command "udisksctl mount -b $TARGET$PART" $LINENO 2>/dev/null
    done
}        


media_filesystem_unmount(){
     local TARGET=$(device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil umount partition"
        return
    fi
    
    media_check_target $TARGET part
    if (( $? )); then
        exit 1
    fi
    run_command "udisksctl unmount -b $TARGET" $LINENO  2>/dev/null
    }
    
    
media_disk_unmount(){
    local TARGET=$(device_fullname $1)
    
    if [[ -z $TARGET ]]; then
        echo "Usage: diskutil umountDisk device"
        echo "Attempt to unmount all the directly-mountable volumes on the disk."
        return
    fi
    
    media_check_target $TARGET disk
    if (( $? )); then
        exit 1
    fi
    
    PARTITION_COUNT=$(media_partition_count $TARGET)
    
    for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
       run_command "udisksctl unmount -b $TARGET$PART" $LINENO  2>/dev/null
    done    
    }    


media_disk_eject(){
        if [[ -z $1 ]]; then
            echo "Usage: diskutil eject device"
            exit
        fi      
        
        TARGET=$(device_fullname $1)
        
        media_check_target $TARGET disk
        if (( $? )); then
            exit 1
        fi
        
        media_disk_unmount $TARGET
        run_command "udisksctl power-off -b $TARGET" $LINENO
    
}


media_name(){
    #lsblk -dpnlo NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    local VEN_MOD=$(lsblk -dpnlo VENDOR,MODEL $1  2> /dev/null | sed 's/  */ /g')
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    local SIZE=$(lsblk -dpnlo SIZE $1  2> /dev/null | sed 's/[ ]\+//g')
    local DEVICE=$(lsblk -dpnlo NAME $1  2> /dev/null)
    
    echo "$VEN_MOD - $SIZE ($DEVICE)"
}


media_partition_fs(){
    local PARTITION=$1
    local DEVICE=
	local PARTNUM=
    local MEDIA_PARTITION_TABLE=
    
    if [ ! -e $PARTITION ]; then
        echo "Partition '$PARTITION' not found"
        return 1
    fi
    
     # get device name
    if [ -z "$(echo $PARTITION | grep p)" ] ;then
        DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    fi
    
    # get partition number
    PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')
    
	
	PARTED_OUTPUT=$(sudo parted -ms $DEVICE print)
#	MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d ':' -f6)   # msdos, gpt, other
#	case $MEDIA_PARTITION_TABLE in
#		  msdos)
			  MEDIA_PARTITION_FS="$(echo "$PARTED_OUTPUT" | grep ^$PARTNUM: | cut -d ':' -f 5)"
#			  ;;
#		  gpt)
#			  MEDIA_PARTITION_FS="$(echo "$PARTED_OUTPUT" | grep ^$PARTNUM: | cut -d ':' -f 5)"
#			  ;;
#		  *)
#			  ;;
#	esac	
    
	
# bandaid
#echo "fs='$MEDIA_PARTITION_FS'"
if  [ -z $MEDIA_PARTITION_FS ]; then
    MEDIA_PARTITION_FS="exfat"
fi    
    
    
	echo "$MEDIA_PARTITION_FS"
}


media_filesystem_verifyXX() {
    local PARTITION=$(device_fullname $1)
    
    if [[ -z $PARTITION ]]; then
        echo "Usage: diskutil verifyFilesystem partition"
        return
    fi
     
    if [ ! -e $PARTITION ]; then
        error $LINENO "Volume $PARTITION does not exist."
        return 1
    fi
    
    media_check_target $PARTITION part 
    if (( $? )); then
   #     error $LINENO "'$PARTITION' is not a partition."
        return 1
    fi 
    
    # -v=verbose -f=force -n=nochanges
    run_command "sudo fsck -v -n $PARTITION"
    
    # run_command "sudo badblocks -s -v $PARTITION"
}


media_filesystem_repair() {
    local PARTITION=$(device_fullname $1)

    if [[ -z $PARTITION ]]; then
        echo "Usage: diskutil repairFilesystem partition"
        return
    fi
     
     
    media_check_target $PARTITION part 
    if (( $? )); then
   #     error $LINENO "'$PARTITION' is not a partition."
        return 1
    fi 
     
     
   # if [ ! -e $PARTITION ]; then
   #     error $LINENO "Volume $PARTITION does not exist."
   #     return 1
   # fi
    
    # -v=verbose -f=force -p=automatic repair
    run_command "sudo fsck -M -v -p $PARTITION"
    
    #run_command "sudo badblocks -s -v $v"
    
    # e2fsck -f -y -v -C 0 '/dev/sda2'
}


media_disk_verify() {
    local DISK=$1
     
    if [[ -z $DISK ]]; then
        echo "Usage: diskutil verifyDisk disk"
        return
    fi     
     
     
    media_check_target $DISK disk 
    if (( $? )); then
        error $LINENO "Disk $DISK does not exist."
        return 1
    fi
    
    run_command "sudo parted $DISK print" $LINENO
        
   # PARTITION_COUNT=$(media_partition_count $TARGET)
   # echo "Checking $PARTITION_COUNT Partitions..."
   # for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
   #    run_command "sudo fsck -M -V $DISK$PART" $LINENO  2>/dev/null
   # done   
    
   # run_command "sudo badblocks -s -v $DISK"
    
}


media_disk_repair() {
    local DISK=$1
     
    if [[ -z $DISK ]]; then
        echo "Usage: diskutil repairDisk disk"
        echo "Attempt to repair partition table"
        return
    fi 
     
    if [ ! -e $DISK ]; then
        error $LINENO "Volume $DISK does not exist."
        return 1
    fi

    media_check_target $DISK disk 
    if (( $? )); then
        return 1
    fi 

    
    #run_command "testdisk $DISK" $LINENO

    #PARTITION_COUNT=$(media_partition_count $TARGET)
    #echo "repairing $PARTITION_COUNT Partitions..."
    #for ((PART=1 ; PART<=$PARTITION_COUNT; PART++)) ; do
    #   run_command "sudo fsck -M -V -y $DISK$PART" $LINENO  2>/dev/null
    #done  
    #run_command "sudo badblocks -s -v $DISK"
    
    echo "Partition table..."
    run_command "sudo parted $DISK print" $LINENO
    
    echo "no changes made"
    echo "If you need to recover a partition, try using 'testdisk' "
}


media_disk_partition () {
    if [[ -z $1 ]]; then
        echo "Usage: disktuil partitionDisk device type filesystem [name] [size]"
        echo "type is: gpt | msdos | mac"
        echo "filesystem is: fat16 fat32 exfat ntfs ext2 ext3 ext4 free"
        echo "Example: diskutil partitionDisk sda gpt"
        eche "Note: this does not work"
        return
    fi
    
    local DEVICE=$1
    local TYPE=$2
    local FILESYSTEM=$3
    local NAME=${4:-$(media_size $DEVICE -h)} 
    local SIZE=${5:-100%} 
    
    media_check_target $DEVICE disk
    if (( $? )); then
        exit 1
    fi    
    
    
     if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
    # ui_msg  "INSTALL:" "$MSG" "white" "OK" "log"
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi   
    
    
exit    
    
    echo "Writing zeros to '$DEVICE'..."
    run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

    echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
    run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO
    
    
}


media_disk_delpartition(){
    local PART_NO=$1
    local DEVICE=$(device_fullname $2)
    local SILENT=$3
    
    if [[ -z $1 ]]; then
        echo "Usage: disktuil delPartition device partition [-s]"
        echo "Example: diskutil delPartition sda 1"
        return
    fi
    
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi
    
    echo "Unmounting $DEVICE$PART_no"
    media_filesystem_unmount $DEVICE$PART_NO

    
    echo "Deleting partition $PART_NO on '$DEVICE '..."
        #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
    run_command "sudo parted $DEVICE rm $PART_NO" $LINENO

}


media_filesystem_check() {
    local PARTITION=$1
    local WAS_MOUNTED=
    local FIX=${2:-nofix}
    
    if [ ! -e $PARTITION ]; then
        error $LINENO "Partition $PARTITION does not exist."
        return 1
    fi
    
    if [[ $(lsblk -ndo type $PARTITION) != part ]]; then
        echo $PARTITION is not a partition.
        return 1
    fi
    
    # get device name
    if [ -z "$(echo $PARTITION | grep p)" ] ;then
        DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    fi
    
    # get partition number
    PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')

    # unmount
    if [[ ! -z "$(df | grep ^$PARTITION)" ]] && [[ $(ui_yesno "Unmount $PARTITION?" ) = y ]]; then
        echo
        echo "Unmounting $PARTITION ..."
        WAS_MOUNTED=true
        #umount $PARTITION
        media_filesystem_unmount $PARTITION
    fi
    
    FILESYSTEM=$(media_partition_fs $1)
    
    ui_echo "FILESYSTEM='$FILESYSTEM'"    
    
    case $FILESYSTEM in
    
        fat16|fat32)           
            ui_echo "Checking fat filesystem..." white log
            run_command "sudo fsck.fat -n $PARTITION" $LINENO   # -n means no-op
            RC=$?
            if (( $RC )); then
                ui_msg_error $LINENO "fsck.fat failed with rc $RC"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    return 1
                fi
                ui_echo "Trying to recover corrupted filesystem..."
                run_command "sudo fsck.fat -a -w -v $PARTITION"  $LINENO
                RC=$?
                if (( $RC )); then
                    error $LINENO "fsck.fat failed with rc $RC"
                    return 1
                fi
            fi
            ;;
            
            
        exfat)
            echo "Checking exfat filesystem..."
            run_command "sudo fsck.exfat -n $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "fsck.exfat failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    return 1
                fi
                info "Trying to recover corrupted filesystem..."
                run_command "sudo fsck.exfat -a $PARTITION"    $LINENO
                rc=$?
                if (( $rc )); then
                    error $LINENO "fsck.fat failed with rc $rc"
                    return 1
                fi
            fi
            ;;
            
        
        ext2|ext3|ext4)
            echo "Checking ext_ filesystem"
            run_command "sudo e2fsck -pf $PARTITION"  $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "e2fsck failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    return 1
                fi
                info "Trying to recover corrupted filesystem"               
                run_command "sudo e2fsck -y $PARTITION" $LINENO
                rc=$?
                if [  $rc = 0 ]; then
                    return 0
                else    
                    error $LINENO "e2fsck failed with rc $rc"
                    #return 1
                fi

                #if [[ $repair == true ]]; then
                #    info "Trying to recover corrupted filesystem - Phase 2"
                #    sudo e2fsck -fy -b 32768 "$PARTITION"
                #    (( $? < 4 )) && return
                #fi
                
                run_command "sudo resize2fs $PARTITION"  $LINENO
                run_command "sudo e2fsck -pf $PARTITION" $LINENO
                run_command "sudo resize2fs $PARTITION"  $LINENO
                rc=$?
                if (( $rc )); then 
                    error $LINENO "e2fsck failed with rc $rc"
                    return 1
                fi  
            fi         
            ;;
            
            
        ntfs)
            echo " - Clearing ntfs dirty flag..."
            run_command "sudo ntfsfix -d $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "ntfsfix failed with rc $rc"
                if [[ $(ui_yesno "Errors found.  Try to fix?" ) != y ]]; then
                    return 1
                fi
                echo " - Check filesystem... fix errors..."           
                run_command "sudo ntfsresize -i -f -v $PARTITION" $LINENO    # from gparted
                if (( $rc )); then
                    error $LINENO "ntfsresize failed with rc $rc"
                    return 1
                fi       
            
                echo " - Check that ntfs filesystem is ready for resize..."     
                run_command "sudo ntfsresize -c $PARTITION" $LINENO   
                if (( $rc )); then
                    error $LINENO "ntfsresize failed with rc $rc"
                    return 1
                fi    
            fi    
            ;;
            
            
        *)
            error $LINENO "Filesystem '$FILESYSTEM' not supported"
            #return 5
            exit
            ;;
    esac
    
     if [ $WAS_MOUNTED ]; then
        echo Remounting $PARTITION...
        media_filesystem_mount $PARTITION
    fi
    
    ui_echo "~ filesystem_check OK" green
}


media_partition_count(){
    local MEDIA=$1
    
     parted_output="$(sudo parted -ms "$MEDIA" unit B print)"
     partnum="$(echo "$parted_output" | tail -n 1 | cut -d ':' -f 1)"
    
    echo $partnum
    exit
    
    return $partnum
}


retire_media_partition_resize(){
    local PARTITION=$1
    local BEG_BYTE=$2  
    local END_BYTE=$3   # or min or maxst run using both the -n and 
    local DEVICE
    local SIZE_BYTES=$(( $END_BYTE - $BEG_BYTE ))
    
# to disable... this just runs     
return 1    
    
        media_check_target $TARGET part
        if (( $? )); then
            exit 1
        fi       
  
  #      media_partition_resize $TARGET $SPECS
  #      media_partition_verify $TARGET    
    
    
    
    
    if [ "$FILESYSTEM" = "fat16" ] || [ "$FILESYSTEM" = "fat32" ]; then
        echo fat partitions resize with the filesystem.  exiting.
        return
    fi
    
    
    if ! $(is_number $BEG_BYTE) ; then
        error $LINENO "bad BEG_BYTE '$BEG_BYTE'"
    fi
    if ! $(is_number $END_BYTE) ; then
        error $LINENO "bad END_BYTE '$END_BYTE'"
    fi
    
    
    echo_white "Resizing partition to $(bytes $SIZE_BYTES) ..."
    
    if [ ! -e $PARTITION ]; then
        error $LINENO Partition does not exist
        return 1
    fi
    
    if [ ! $BEG_BYTE ] || [ ! $END_BYTE ] ; then
        error $LINENO "beg byte or end byte is blank '$BEG_BYTE '$END_BYTE' "
        return 2
    fi
    
    
    # get device name
    if [ -z "$(echo $PARTITION | grep p)" ] ;then
        DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    fi
    
    # get partition number
    PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')

    
    # get filesystem
    parted_output="$(sudo parted -ms "$DEVICE" unit B print)"
    rc=$?
    if (( $rc )); then
        error $LINENO "parted failed with rc $rc"
        error $LINENO "Possibly invalid image. Run 'parted $MEDIA unit B print' manually to investigate"
        return 6
    fi
    FS="$( echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 5 )"


echo "FS.................='$FS'"    
   if [ -z $FS ]; then
        FS=ntfs
        echo "FS.................=$FS"   
        echo "Cannot resize '$FS' partitions"
        return 1
   fi
   
    # See if BEG_BYTE matches the partition table
    BEG="$( echo "$parted_output" | grep ^$PARTNUM: | cut -d ':' -f 2 | tr -d 'B')"
    if [ $BEG -ne $BEG_BYTE ]; then
        error $LINENO Error in Beginning Byte
        return 10
    fi


run_command "sudo parted $DEVICE unit B resizepart $PARTNUM $END_BYTE" $LINENO

return



#old way...
   
    #delete partition
    echo Delete partition...
    #echo_blue parted -s -a minimal "$DEVICE" rm "$PARTNUM"
    run_command "sudo parted -s -a minimal $DEVICE rm $PARTNUM" $LINENO
    rc=$?
    if (( $rc )); then
        echo $LINENO "parted failed with rc $rc"
        return 1
    fi
    
    # recreate partition
    echo "Recreate partition...'$BEG_BYTE' '$END_BYTE'"
    #echo_blue parted  "$DEVICE" unit B mkpart primary "$filesystem" "$BEG_BYTE" "$END_BYTE"
    #run_command "sudo parted $DEVICE unit B mkpart primary $FILESYSTEM $BEG_BYTE $END_BYTE" $LINENO
    run_command "sudo parted $DEVICE unit B mkpart primary $FS $BEG_BYTE $END_BYTE" $LINENO
    rc=$?
    if (( $rc )); then
        echo $LINENO "parted failed with rc $rc"
        echo restoring old partition
        sudo parted  "$DEVICE" unit B mkpart primary "$filesystem" "$PART_START" "$PART_END"
        return 2
    fi
}


media_partition_rename () {
    local PARTITION=$1
    local PARTITION_NUMB=
    local NAME=$2
    
    
    run_command 'sudo parted $PARTITION name "$NAME"' $LINENO
    
}


media_filesystem_resize(){
    #Resize filesystemst run using both the -n and 
    local PARTITION=$1
    local SIZE=$2  # min max bytes
    
    local FS_TYPE=$(  )   
    echo
    echo_white "Resize filesystem..."

    
    # get file system type
    if [ -z "$(echo $PARTITION | grep p)" ] ;then
        DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    fi
    
    PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')
    
    if [ ! -e "$DEVICE" ]; then
        error $LINENO "Device '$DEVICE' does not exist"
        return 1
    fi 

    if [ ! -e "$DEVICE$PARTNUM" ]; then
        error $LINENO "PARTITION '$DEVICE$PARTNUM' does not exist"
        return 1
    fi 
    
    FS_TYPE=$(sudo parted -ms "$DEVICE" unit B print free |  grep -v $DEVICE | grep -v free | grep ^$PARTNUM: | cut -d ':' -f 5 )
    if (( -z $FS_TYPE )); then
        FS_TYPE=exfat
    fi
  
  
  
    # get current fs size
    case $FS_TYPE in
        fat16|fat32)
            FS_SIZE=$(sudo fatresize -i  $PARTITION | grep Cur | cut -d: -f2 | sed 's/ //g')
            FS_MIN=
            FS_MAX=
            ;;
        
        exfat)
            FS_SIZE=$(sudo fsck.exfat  $PARTITION | grep Volume | cut -d : -f2 | sed 's/Volume size//g' | sed 's/ //g')
            FS_SIZE=$(get_bytes $FS_SIZE)
            FS_MIN=
            FS_MAX=
            ;;
        
        ntfs)
            FS_SIZE=$(sudo ntfsresize -i  $PARTITION | grep "Current device" | cut -d: -f2 | cut -d" " -f2 | sed 's/ //g')
            FS_MIN=
            FS_MAX=
            ;;
        
        ext2|ext3|ext4)
            FS_BLOCKS=$(sudo tune2fs -l $PARTITION |  grep '^Block count:' | tr -d ' ' | cut -d ':' -f 2)
            FS_BLOCKSIZE=$(sudo tune2fs -l $PARTITION |  grep '^Block size:' | tr -d ' ' | cut -d ':' -f 2)
            FS_SIZE=$(($FS_BLOCKS*$FS_BLOCKSIZE))
            FS_MIN=
            FS_MAX=
            ;;
        
        *)
            echo Unsupported file system '$FS_TYPE' ;;
    esac
  
  
  
  
  
  
  
  
  echo SIZE="'$SIZE'"
    
    case $SIZE in
        min)
            EXT4_SIZE="$(($NEW_SIZE / 1024))K"
            NTFS_SIZE="-s $NEW_SIZE"
            EXFAT_SIZE="-s $NEW_SIZE "
            FAT_SIZE="-s $NEW_SIZE"
            ;;
            
        max)
            EXT4_SIZE=
            NTFS_SIZE="-s $NEW_SIZE"
            EXFAT_SIZE="-s max "
            FAT_SIZE="-s $NEW_SIZE"
            ;;
            
        *)
            EXT4_SIZE="$((SIZE / 1024))K"
            NTFS_SIZE="-s $SIZE"
            EXFAT_SIZE=" "
            FAT_SIZE="-s $SIZE"
            ;;
    esac 
  
  
  
  
    
    case $FS_TYPE in
    
        ext2|ext3|ext4)
            echo
            echo_white  "Resizing ext4 filesystem to '$EXT4_SIZE'...line ($LINENO)"
            run_command "sudo e2fsck -fy $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
                error $LINENO "e2fsck -f failed with rc $rc "
                #return 12
            fi
            sleep 2
            
            if [ -z "$EXT4_SIZE" ]; then
                run_command "sudo resize2fs  $PARTITION"  $LINENO
                rc=$?
            else
                #echo_blue resize2fs  "$PARTITION" "$EXT4_SIZE"
                run_command "sudo resize2fs  $PARTITION $EXT4_SIZE" $LINENO
                rc=$?            
            fi    
            if (( $rc )); then
                error $LINENO "resize2fs failed with rc $rc.  returning "
                return $rc
            fi
            sleep 2
            ;;
        
        fat16|fat32)
            echo
            echo_white "Resizing fat filesystem '$FAT_SIZE'...line ($LINENO)"
            run_command "sudo fatresize -p -s $FAT_SIZE $PARTITION" $LINENO
            if (( $? )); then
              return 1
            fi   
            sleep 2
            run_command "sudo fatresize -i $PARTITION" $LINENO
            ;;
        
        exfat)
            echo
            echo_white "Resizing exfat filesystem '$EXFAT_SIZE'...line ($LINENO)"
            #echo_blue fatresize -p "$FAT_SIZE" "$PARTITION"
            run_command "sudo fatresize -p $FAT_SIZE $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
              error $LINENO "resize2fs failed with rc $rc"
              return $rc
            fi   
            sleep 2
            
            echo
            
            run_command "sudo fatresize -i $PARTITION" $LINENO
            ;;            
            
            
                
        ntfs)
            echo
            echo_white "Resizing ntfs filesystem '$NTFS_SIZE'..."
            
            echo
            echo_white "Check filesystem is ready for resizing...line ($LINENO)"           
            #echo_blue ntfsresize -c "$PARTITION"
            run_command "sudo ntfsresize -c $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
              error $LINENO "ntfsresize failed with rc $rc"
              return $rc
            fi        
            
            
            echo_white "Simulate resize ntfs fs...line ($LINENO)"
            #echo_blue ntfsresize -f -f -n -P "$NTFS_SIZE" "$PARTITION"
            run_command "sudo ntfsresize -f -f -n -P $NTFS_SIZE $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
              error $LINENO "ntfsresize failed with rc $rc"
              return $rc
            fi        
    
        
            echo_white "Resize ntfs fs...($LINENO)"
            #echo_blue ntfsresize -f -f "$NTFS_SIZE" "$PARTITION"
            run_command "sudo ntfsresize -f -f $NTFS_SIZE $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
              error $LINENO "ntfsresize failed with rc $rc"
              return $rc
            fi
            
            sleep 2
            echo_white "Clear ntfs dirty flag... line ($LINENO)"
            #echo_blue ntfsfix -d $PARTITION
            run_command "sudo ntfsfix -d $PARTITION" $LINENO
            rc=$?
            if (( $rc )); then
              error $LINENO "ntfsfix failed with rc $rc"
              return $rc
            fi
            
            echo_white ntfs info...
            #echo_blue ntfsresize -i $PARTITION
            run_command "sudo ntfsresize -i $PARTITION" $LINENO
            echo
            sleep 2
            ;;
            
       *)
            error $LINENO.
            ;;
            
    esac
}




media_size() {
    local DEV=$1
    local HUMAN=${2:-"no"}
   
     # add '/dev/' if missing
    if [[ ${DEV:0:5} != "/dev/" ]]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        DEV="/dev/"$DEV
    fi
   
    SIZE_BYTES=$(lsblk $DEV -dnbo size  2> /dev/null)
    RC=$?
    if (( $RC )); then
        echo 0
        return $RC       
    fi
    
    if [[ $HUMAN = "-h" ]]; then
        echo $(get_bytes $SIZE_BYTES -h)
    else
        echo $SIZE_BYTES
    fi
    
    # an alternative way:
    # echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
    # echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


media_partition_format(){
    local FORMAT=$1
    local FS_NAME=$2
    local PARTITION=$(device_fullname $3)
    
    if [[ -z $FORMAT ]]; then
        echo "Usage: diskutil erasePartition format name partition"
        exit
    fi
    
    
    
    if [[ -z $PARTITION ]] ; then
        ui_msg_error $LINENO "Partition not specified."
        lsblk -dp
        exit 1
    fi
    
    if [[ $(lsblk -ndo type $PARTITION) != part ]]; then
        error $LINENO "$PARTITION is not a partition."
        exit 2
    fi
    
    
 #   if [[ $SILENT != -y ]]; then
 #       RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
 #       echo
 #       if [[ $RESULT != y ]]; then
 #           ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
 #           return 1
 #       fi
 #   fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
    # ui_msg  "INSTALL:" "$MSG" "white" "OK" "log"
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi
    
    
    
    echo "Unmounting 'PARTITION'..."
    #run_command "sudo umount $DEVICE 2> /dev/null"
    media_filesystem_unmount $PARTITION
    
    echo "Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat16)  
            run_command "sudo mkfs.vfat -F16 -v -I -n $FS_NAME $PARTITION" $LINENO
            ES=$?
            ;;

        fat32)
            run_command "sudo mkfs.vfat -v -I -n $FS_NAME $PARTITION" $LINENO
            ES=$?
            ;;
            
        exfat)
            run_command "sudo mkfs.exfat -n $FS_NAME $PARTITION" $LINENO
            ES=$?
            ;;      
        
        ntfs)
            run_command "sudo mkfs.ntfs -f -L $FS_NAME $PARTITION" $LINENO
            ES=$?
            ;;
        
        ext2 | ext3 | ext4)
            run_command "sudo mkfs -t $FORMAT -L $FS_NAME -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            ES=$?
            ;;
            
        hfs)
            run_command "sudo mkfs.hfs -v $FS_NAME $PARTITION" $LINENO
            ;;
            
        *)
            ui_msg_error $LINENO "Unknown format '$FORMAT'"
            
    esac

    if (( $ES)); then
  #      ui_msg_error $LINENO "mkfs failed"
        return 1
    else
        ui_msg "ERASE MEDIA" "~ Format complete. '$(media_name $DEVICE)' has been erased." white "" log
    fi

    echo "Mounting the drive..."
    sleep 2
    media_filesystem_mount $PARTITION
      
}


media_partition_reformat(){
    local PARTITION=$( device_fullname $1)
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil reformat partition"
        echo Example: diskutil reformat /dev/sda1
        return
    fi
    
    media_check_target $PARTITION part
    if (( $? )); then
        return 1
    fi
    
    FS=$(lsblk -n -o FSTYPE $PARTITION)
    NAME=$(lsblk -n -o LABEL $PARTITION)
    
    if [[ "$FILESYSTEMS" != *"$FS"* ]]; then
        echo $FS is not a supported filesystem
        return 1
    fi

    media_partition_format $FS "$NAME" $PARTITION
}


media_disk_format(){
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil eraseDisk format name device"
        echo "Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4"
        echo Example: diskutil eraseDisk ntfs Untitled /dev/disk3
        echo Example: diskutil eraseDisk exfat NEWDISK /dev/sda
        return
    fi

    local FORMAT=${1:-"fat32"}    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=$2
    local DEVICE=$(device_fullname $3)
    local SILENT=$4   # -y
    
    
    media_check_target "$DEVICE" disk 
    if (( $? )); then
        return 1
    fi 
    
    local ROOT="$(env_root_device)"
    local TYPE="$(lsblk $DEVICE -dnpo TYPE)"
   # local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE,TYPE) ($DEVICE)"
    local PARTITION=$DEVICE

	if [[ ${FORMAT:0:3} = fat ]] ; then   
		PART_TABLE=msdos
		PART_TYPE=primary
		PART_NAME=
	else
		PART_TABLE=gpt
		PART_TYPE=
		PART_NAME=PART1    
	fi

	if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi
	

    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi


    echo "Unmounting '$DEVICE'..."
    media_disk_unmount $DEVICE

    echo "create partition table"
    media_disk_createpartitiontable $PART_TABLE $DEVICE -y
    if (( $? )); then
        return 1
    fi
    echo_green DONE


    echo "Creating partition on '$DEVICE'..."
    media_disk_addpartition $FORMAT $NAME "100%" $DEVICE -y
    if (( $? )); then
        return 1
    fi
    echo_green DONE
  
    # mount the drive with udisksctl if installed
    media_filesystem_mount $DEVICE\1

}

media_disk_formatxx(){
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil eraseDisk format name device"
        echo "Format is: fat16 | fat32 | exfat | ntfs | ext2 | ext3 | ext4"
        echo Example: diskutil eraseDisk ntfs Untitled /dev/disk3
        echo Example: diskutil eraseDisk exfat NEWDISK /dev/sda
        return
    fi

    local FORMAT=${1:-"fat32"}    # fat16, fat32, exfat, ntfs, ext2, ext3, ext4
    local NAME=$2
    local DEVICE=$(device_fullname $3)
    local SILENT=$4   # -y
    
    
#echo $NAME
#exit    
    
    media_check_target "$DEVICE" disk 
    if (( $? )); then
        return 1
    fi 
    
    local ROOT="$(env_root_device)"
    local TYPE="$(lsblk $DEVICE -dnpo TYPE)"
   # local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE,TYPE) ($DEVICE)"
    local PARTITION=$DEVICE

	if [[ ${FORMAT:0:3} = fat ]] ; then   
		PART_TABLE=msdos
		PART_TYPE=primary
		PART_NAME=
	else
		PART_TABLE=gpt
		PART_TYPE=
		PART_NAME=PART1    
	fi

	if [[ $FORMAT = exfat ]]; then
		FS_TYPE=ntfs
	else
		FS_TYPE=$FORMAT
	fi
	

    if [[ -z $DEVICE ]] ; then
        ui_msg_error $LINENO "Device not specified."
        lsblk -dp
        return 1
    fi

    if [[ ! -e $DEVICE ]]; then
        ui_msg_error $LINENO "'$DEVICE' does not exist"
        return 2
    fi

    if [[ $DEVICE = $ROOT ]] ; then
        ui_msg_error $LINENO "Can not format root device"
        return 3
    fi
    
    # Stop if dev is the root device
    if [[ $DEVICE = $(env_root_device) ]]; then
        ui_msg_error $LINENO "Format root device not allowed"
        return 3
    fi

    ui_echo "$PRODUCTNAME $SCRIPTVER Format '$(media_name $DEVICE)' to '$FORMAT'..." white
    
    if [[ $SILENT != -y ]]; then
        RESULT=$(ui_yesno "ERASE MEDIA" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$DEVICE' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        echo
        if [[ $RESULT != y ]]; then
            ui_msg "ERASE MEDIA" "~ $DEVICE not erased. you answered '$RESULT'" "" "" log
            return 1
        fi
    fi

    ui_countdown 10 "ERASE MEDIA"  # "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        ui_msg  "ERASE MEDIA"  "~ Erase Media stopped." "" "" log
        return 2
    fi




    echo "Unmounting '$DEVICE'..."
    sudo umount $DEVICE 2> /dev/null
    sudo umount $DEVICE? 2> /dev/null

    # if selected whole disk... wipe the partition table and make a new partition table.
    if  [[ $TYPE = disk ]]; then
       
        echo "Writing zeros to '$DEVICE'..."
        run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=5K" $LINENO

        echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
        run_command "sudo parted -s $DEVICE mklabel $PART_TABLE" $LINENO




        echo "Creating partition on '$DEVICE'..."
     #   run_command "sudo dd if=/dev/zero of=$DEVICE bs=512 count=4" $LINENO
     
        # need to limit size to 4G if fat16    
        if [[ $FS_TYPE = fat16 ]] && [[ $(media_size $DEVICE) -gt $(get_bytes 4G) ]]; then
            SIZE=4G
        else
            SIZE=100%
        fi           

        run_command "sudo parted -s -a opt $DEVICE mkpart $PART_TYPE $PART_NAME $FS_TYPE 1M $SIZE" $LINENO
        
      #  echo "Set Partition name to ..."
        #run_command "   " $LINENO
        
        PARTITION=$DEVICE\1    
    fi    

    sleep 2
    echo "Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat16) 
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -F16 -v -I -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;

        fat32)
            if [[ -z $(which mkfs.vfat) ]] ; then
                echo Installing vfat support ...
                sudo $INSTALL dosfstools
            fi
            run_command "sudo mkfs.vfat -v -I -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;
            
        exfat)
            #https://unix.stackexchange.com/questions/61209/create-and-format-exfat-partition-from-linux
            if [[ -z $(which mkfs.exfat) ]] ; then
                echo Installing exfat support ...
                sudo $INSTALL exfat-utils 
                sudo $INSTALL exfat-fuse 
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi    
            run_command "sudo mkfs.exfat -n '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;      
        
        ntfs)
            if [[ -z $(which mkfs.ntfs) ]] ; then
                #sudo apt-get install fuse ntfs-3g
                echo Installing ntfs support...
                sudo $INSTALL fuse 
                sudo $INSTALL ntfs-3g 
                sudo $INSTALL ntfsprogs  #ntfsprogs is for arch
                #sudo modprobe fuse 
                #echo "fuse" | sudo tee -a /etc/modules
            fi  
            run_command "sudo mkfs.ntfs -f -L '$NAME' $PARTITION" $LINENO
            ES=$?
            ;;
        
        ext2 | ext3 | ext4)
          #  run_command "sudo mkfs -t $FORMAT -L $NAME -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            run_command "sudo mkfs -t $FORMAT -L '$NAME' -E root_owner=$UID:$GID -F $PARTITION" $LINENO
            ES=$?
            ;;
            
        *)
            ui_msg_error $LINENO "Unknown format '$FORMAT'"
            
    esac

    if (( $ES)); then
  #      ui_msg_error $LINENO "mkfs failed"
        return 1
    else
        ui_msg "ERASE MEDIA" "~ Format complete. '$(media_name $DEVICE)' has been erased." white "" log
    fi

    # mount the drive with udisksctl if installed
    if [[ $(env_which udisksctl) ]]; then
        echo "Mounting the drive..."
        sleep 2
        run_command "udisksctl mount -b $PARTITION" $LINENO
        if (( $? )); then
            ui_msg_warning $LINENO "mount failed"
            return 1
        fi
    fi    
}




media_clone(){
    SOURCE=$1
    TARGET=$2
    

    # get info
 #   if [[ $SKIP_FREESPACE = "on" ]]; then

		START_OF_FREESPACE=$(sudo parted -ms "$SOURCE" unit B print free)
		RC=$?
		if (( $RC )); then
			error $LINENO "parted failed with rc $RC"
            do_beep_down
			exit 15
		fi
		START_OF_FREESPACE=$(tail -1 <<< "$START_OF_FREESPACE" | grep free | cut -d ':' -f 2 | tr -d 'B')
		if ! (( $START_OF_FREESPACE )); then 
			START_OF_FREESPACE=$(media_size $SOURCE)
		fi

		BYTES_TO_READ=$START_OF_FREESPACE
		BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1 ))

		echo Media size=$(media_size $SOURCE -h)
		echo Skipping $(get_bytes $(( $(media_size $INDEV) - $START_OF_FREESPACE )) -h ) of freespace at end.
		echo Reading=$(get_bytes $START_OF_FREESPACE -h)

#	else
	  BYTES_TO_READ=$(media_size $INDEV)
	  BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

#	fi    
	#end of new section    
    
    # check if there is space
    SOURCE_SIZE=$(sudo lsblk -ndb $SOURCE -o size)
    TARGET_SIE=$()    
        
    # ask to procede
    
    #do it
    #sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
    if [[ ! -z $(which pv) ]]; then
#		sudo pv $SOURCE -s $BYTES_TO_READ | dd bs=$BS of=$TARGET count="$BLOCKS_TO_READ" iflag=fullblock conv=fsync 
		RC=$?
    else
      echo "Note: 'pv' is not installed so there is no progress indicator for this step. Please wait..."
#      sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img  conv=fsync 
      RC=$?
    fi
    if (( $RC )); then
        do_beep_down
        return $RC
    fi
}


media_check_target(){
    local TARGET=$1
    local TYPE=$2    # disk or part
    
    if [[ -z $TARGET ]]; then
        echo Target is blank
        return 1
    fi
    
    if [[ ! -e $TARGET ]]; then
        echo "Target '$TARGET' does not exist"
        return 1
    fi
    
    if [[ $(lsblk $TARGET -n -d -o TYPE) != $TYPE ]]; then
        echo "Target '$TARGET' is not type '$TYPE'"
        return 1
    fi        
}

media_fix(){
    PARTITION=$1
    # NOT DONE
    
    if [[ ! -e $PARTITION ]]; then
        error $LINENO "Partition '$PARTITION' does not exist"
        return 1
    fi
    
    # if mounted, then unmount it
    if [[ ! -z $(df | grep $PARTITION) ]]; then
        media_partition_unmount $PARTITION
        if (( $? )); then
            error $LINENO error unmounting
            return 1
        fi
    fi    
    
    echo $(media_partition_fs $PARTITION)
    
    case $(media_partition_fs $PARTITION) in
        ext4)
            #check filesystem for errors and fix if possible
            e2fsck -f -y -v -C O '/dev/sda3'
            #grow file system to fill partition
            #resize2fs -p '/dev/sda3'
            ;;
            
        fat32)
            fsck.fat -y -V $PARTITION
            ;;
        
        exfat)
            sudo fsck -M -C -y $PARTITION
            ;;
   esac 
}



media_disk_wipe(){
    local DEVICE=$1
    local PATTERN=${2:-zero}   # zero | random | shred
    local SILENT=${3:-n}  #-y or -n

    media_check_target $DEVICE disk 
    if (( $? )); then
        return 1
    fi    
    
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local PART1=$DEVICE\1    
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))

    if [ $1 = $ROOT ] ; then
        ui_msg  "Error 3" "Can not wipe root device"
        return 3
    fi

 
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "WIPE MEDIA" "All existing data on '$NAME' ($DEVICE) will be erased.  The device will be overwritten with $PATTERN.  Are you sure you want to continue? y/n?" "--defaultno")
        if [ $RESULT != "y" ]; then
            echo
            ui_msg "WIPE MMEDIA" "'$DEVICE' not erased"
            return
        fi
    fi
 
    #Countdown 
    do_beep
    ui_countdown 10 "" "Wiping Media '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "WIPE MEDIA" "Wipe Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    

    echo_white Wiping $DEVICE...

    echo Unmounting $DEVICE...
    sudo umount $DEVICE? 2>/dev/null

    if [[ $PATTERN = "shred" ]];then
        run_command "shred -v $DEVICE" $LINENO 
        return
    fi


    MESSAGE="Wiping '$NAME' ($DEVICE)\n\nWriting $PATTERN to $DEVICE... "  
    if [ $INTERFACE = "cli" ]; then
        echo_white "Writing $PATTERN to $DEVICE... "  
        pv -s $DEVICE_SIZE_BYTES /dev/$PATTERN | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT
        EXIT_CODE=$?
    else
        (sudo pv -n -s $DEVICE_SIZE_BYTES /dev/$PATTERN | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "WIPE MEDIA" --gauge "\n$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 5
        TEST_RESULTS=Failed
        return 5
    else
        TEST_RESULTS=Succeeded
        
    fi

    echo
    ui_msg "WIPE MEDIA" "'$NAME' ($DEVICE) has been wiped with zeros \n\nYou can remove the SD card from the reader"   
    
    pisafe_write_log "WIPE MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}



# -----------------------------------------------------------------------------------------------

media_device_devicename(){
    # returns a clean devicename
    
    local DEVICE=$1
    
    if [[ -z $DEVICE ]]; then
        return
    fi
    
    # remove the partition number from then end
    if [ -z "$(echo $DEVICE | grep p)" ] ;then
        DEVICE=$(echo $DEVICE | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $DEVICE | sed 's/p[1-9]*//g')
    fi
    
    # add /dev/ if missing
    if [[ ${DEVICE:0:5} != "/dev/" ]]; then    # "Device prefix not specified.  Adding '/dev/'"
        echo "/dev/$DEVICE"
    else
        echo "$DEVICE"
    fi
}


media_device_partnum(){
    # returns the partition number if present.  Same as returns the last digits in the string.
    echo $1 | sed 's/.*[^0-9]\(.*\)$/\1/'
}


media_device_type(){
    local DEVICE=$(media_device_devicename $1) 
    lsblk $DEVICE -n -d -o TYPE
}


media_device_checktarget(){
    local TARGET=$(media_device_devicename $1)$(media_device_partnum $1) 
    local TYPE=$2    # disk or part

    
    if [[ -z $TARGET ]]; then
        echo "Target is blank"
        return 1
    fi
    
    if [[ ! -e $TARGET ]]; then
        echo "Target '$TARGET' does not exist"
        return 1
    fi
    
    #if [[ $(lsblk $TARGET -n -d -o TYPE) != $TYPE ]]; then
    if [[ $(media_device_type $TARGET) -ne $TYPE ]]; then
        echo "Target '$TARGET' is not type '$TYPE'"
        return 1
    fi        
}




# -----------------------------------------------------------------------------------------------


media_wipe_old(){
    local DEVICE=$1
    local SILENT=${2:-n}  #-y or -n
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local PART1=$DEVICE\1    
    
    if [ -z $1 ] ; then
        ui_msg  "Error 1"  "Device not specified, choose:"
        return 1
    fi

    if [ ! -e $DEVICE ]; then
        ui_msg  "Error 2" "$DEVICE does not exist"
        return 2
    fi
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))


    if [ $1 = $ROOT ] ; then
        ui_msg  "Error 3" "Can not wipe root device"
        return 3
    fi
    
    if  [ $TYPE != disk ]; then
        ui_msg  "Error 4" "$DEVICE is not a disk"
        return 4
    fi

 
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "WIPE MEDIA" "All existing data on '$NAME' ($DEVICE) will be erased.  Are you sure you want to continue? y/n?" "--defaultno")
        if [ $RESULT != "y" ]; then
            echo
            ui_msg "WIPE MMEDIA" "'$DEVICE' not erased"
            return
        fi
    fi
 
    #Countdown 
    do_beep
    ui_countdown 10 "" "Wiping Media '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "WIPE MEDIA" "Wipe Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    

    echo_white Wiping $DEVICE...

    echo Unmounting $DEVICE...
    umount $DEVICE? 2> /dev/nul

    MESSAGE="Wiping '$NAME' ($DEVICE)\n\nWriting zeros to $DEVICE... "  
    if [ $INTERFACE = "cli" ]; then
        echo_white "Writing zeros to $DEVICE... "  
        pv -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT
        EXIT_CODE=$?
    else
        (sudo pv -n -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "WIPE MEDIA" --gauge "\n$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 5
        TEST_RESULTS=Failed
        return 5
    else
        TEST_RESULTS=Succeeded
        
    fi

    echo
    ui_msg "WIPE MEDIA" "'$NAME' ($DEVICE) has been wiped with zeros \n\nYou can remove the SD card from the reader"   
    
    pisafe_write_log "WIPE MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}



media_test_pattern(){
    local DEVICE=$1
    local PATTERN=$2   # in octal  eg '\377'
    
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local ROOT="/dev/$(env_root_device)"
    local TEMP_FILE=tmpfile.img


    if [ ! -e $DEVICE ]; then
      ui_msg  "Error 2" "$DEVICE does not exist"
      return 2
    fi
    
    if [ $1 = $ROOT ] ; then
        ui_msg  "Error" "Can not test root device"
        return 1
    fi
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    
    # block=4M
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))
  
# just do 2% for testing
#DEVICE_BLOCK_COUNT=$(( $DEVICE_BLOCK_COUNT / 20 ))

     
    date 
    TIME1=$(date +%s)
    MESSAGE="$MESSAGE \nTESTING $PATTERN\nStep 1 of 3: Writing  ... "
#    if [ $INTERFACE = "cli" ]; then
        echo_white "Step 1 of 3: Writing '$PATTERN'..."   
        tr '\000' $PATTERN  </dev/zero | sudo pv -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT 
        EXIT_CODE=$?
#    else
#        (tr '\000' $PATTERN </dev/zero | sudo pv -n -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT ) 2>&1  \
#        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0 
#        EXIT_CODE=$?
#    fi    
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "ERROR 1" "Writing" "red"
        return 1
    fi
    
#######
#sudo hexedit /dev/sdb

    
    date
    TIME2=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME1 $TIME2))\nStep 2 of 6: Reading  ... "
#     if [ $INTERFACE = "cli" ]; then
        echo_white "Step 2 of 3: Reading '$PATTERN' ..."
        sudo pv -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock 
        EXIT_CODE=$?
#     else
#        (sudo pv -n -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock) 2>&1 \
#        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0 
#        EXIT_CODE=$?
#     fi
    if [ $EXIT_CODE != 0 ]; then
        ui_msg "ERROR 2" "Reading" "red"
        return 2
    fi
    
    
    date
    TIME3=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME2 $TIME3))\nStep 3 of 6: Comparing... "
 #   if [ $INTERFACE = "cli" ]; then
        echo_white "Step 3 of 3: Compare '$PATTERN'..."
        pv -s $DEVICE_SIZE_BYTES <(tr -dc $PATTERN <$TEMP_FILE) | cmp $TEMP_FILE
        EXIT_CODE=$?
 #   else
  #      (pv -n -s $DEVICE_SIZE_BYTES <(tr -dc $PATTERN <$TEMP_FILE) | cmp $TEMP_FILE) 2>&1 \
  #      | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
  #      EXIT_CODE=$?
 #   fi
    
#echo ec=$ec
#echo EC=$EXIT_CODE    
#EXIT_CODE=$ec
    
    date
    TIME4=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME3 $TIME4))"
  
    if [ $EXIT_CODE != 0 ]; then
        #ui_msg "ERROR 3" "Comparing" "red"
        MESSAGE="$MESSAGE\nFAILED "
        return 3
    else    
        MESSAGE="$MESSAGE\nPASSED "
    fi
}



media_test(){
    local DEVICE=$1
    local SILENT=${2:-"-n"}
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    #  local ROOT="/dev/$(env_root_device)"
    #  local TEMP_FILE=tmpfile.img
    MESSAGE=
    # ones  = '/377'     = 11111111
    # zeros = '/000'     = 00000000
    # alt   = '/125'     = 01010101
    
    if [ ! -e $DEVICE ]; then
      ui_msg  "Error 2" "$DEVICE does not exist"
      return 2
    fi
    if [ $SILENT != '-y' ]; then
        MSG="WARNING!! '$NAME' ($DEVICE) will be completely erased in testing.  Back it up first if needed.  \n\nThis will switch to a terminal screen to do the testing.  \n\nAre you sure you want to continue?"
        RESULT=$(ui_yesno "TEST MEDIA '$NAME' $DEVICE" "$MSG" "--defaultno")
        if [ $RESULT != 'y' ] ; then
          return 3
        fi
    fi
    
    # countdown
    do_beep
    ui_countdown 10 "" "Overwriting '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        #whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA" --msgbox "Test Media stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
		ui_msg	"TEST MEDIA" "Test Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    
    
    OLD_INTERFACE=$INTERFACE
    
    echo_white Unmounting $DEVICE...
    umount $DEVICE? 2> /dev/null
    
    #test with ones \377
    TIME1=$(date +%s)
    media_test_pattern $1 '\377'
    ONES_COMPARE=$?
    if (( $ONES_COMPARE )) ; then
      echo "error in testing ones"
    fi
    
    #test with zeros \000
    TIME2=$(date +%s)
    media_test_pattern $1 "\000"
    ZEROS_COMPARE=$?
    if (( $ZEROS_COMPARE )) ; then
      echo "error in testing zeros"
    fi
  
    INTERFACE=$OLD_INTERFACE
  
    #summary
    TIME3=$(date +%s)
    if [ $ZEROS_COMPARE = 0 ] && [ $ONES_COMPARE = 0 ]; then
       TEST_RESULTS="PASSED"
    else
        TEST_RESULTS="FAILED"
    fi  
    
    
    MESSAGE="$MESSAGE\n\nMedia Test $TEST_RESULTS ($(get_elapsed_time $TIME1 $TIME3))"
    ui_msg "TEST MEDIA '$NAME' $DEVICE"  "$MESSAGE"
    
    pisafe_write_log "TEST MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}


media_filesystem_rename() {
    # changes the filesystem label.  NOT the Partition name
    
    if [[ -z $1 ]]; then
        echo "Usage: diskutil rename[Filesystem] Device newName"
        echo "Example: diskutil rename /dev/sda1 NEWDISK"
        return
    fi
    
    PARTITION=$(device_fullname $1)
    NAME="$2"
    
    media_check_target $PARTITION part
    if (( $? )); then
        return 1
    fi
    
    #media_filesystem_unmount $PARTITION
    
    FS=$(lsblk $PARTITION -n -o FSTYPE)
    echo $FS
    
    case $FS in
        vfat)       run_command "sudo fatlabel $PARTITION '$NAME'" ;;
        exfat)      run_command "sudo exfatlabel $PARTITION '$NAME'" ;;
        ntfs)       run_command "sudo ntfslabel $PARTITION '$NAME'" ;;
        ext4)       run_command "sudo e2label $PARTITION '$NAME'"    ;;
    esac
    
    #media_partition_mount $PARTITION
    
}



retire_media_partition_resize2(){
    # need ntfsresize and fatresize
    # sudo apt install fatresize

    PARTITION=$1
    SIZE=$2
    #SIZE=$(bytes $2 -b)


    
   if [ ! -e "$PARTITION" ]; then
        ((ERRORS++))
        error $LINENO "Partition '$PARTITION' does not exist"
        return 1
    fi
    
    if [[ $(lsblk -ndo type $PARTITION) != part ]]; then
        echo $PARTITION is not a partition.
        exit 1
    fi    
    
    # get device name
    if [ -z "$(echo $PARTITION | grep p)" ] ;then
        DEVICE=$(echo $PARTITION | sed 's/[1-9]*//g')
    else
        DEVICE=$(echo $PARTITION | sed 's/p[1-9]*//g')
    fi
    
    # get partition number
    PARTNUM=$(echo $PARTITION | sed 's/.*[^0-9]\(.*\)$/\1/')
    
    if [ ! -e "$DEVICE" ]; then
        error $LINENO "Device '$DEVICE' does not exist"
        return 1
    fi 

    if [ ! -e "$DEVICE$PARTNUM" ]; then
        error $LINENO "PARTITION '$DEVICE$PARTNUM' does not exist"
        return 1
    fi 



  #  local PARTITION=$1
  #  local BYTES=$2
    #local SIZE=${2:-min}  #min max bytes or fix
    #SIZE=$2 
    local WAS_MOUNTED=
  
    echo_white Starting resize partition...

    # unmount if needed
    echo_white Unmount if needed ...
    if [ ! -z "$(df | grep ^$PARTITION)" ]; then
        echo "Unmounting '$PARTITION' ..."
        WAS_MOUNTED=true
        umount $PARTITION
    fi


    # get all the partition and filesystem info into global variables.
#echo INFO_GET
    info_get
    rc=$?
    if (( $rc )); then
        error $LINENO "Error $rc in info_get"
        return 1
    fi

#echo INFO VALIDATE
    info_validate
    rc=$?
    if (( $rc )); then
        error $LINENO "Error $rc in info_validate"
        #return 1
    fi


    # set the mode to operate in
    if [ $CMD = "fix" ]; then
        if [ $FS_SIZE -lt $PART_SIZE ]; then
            MODE=grow_fs
        else
            MODE=grow_part       
        fi
    else
        if [ $NEW_SIZE -le $PART_SIZE ]; then
            MODE=shrink
        else
            MODE=grow
        fi    
    fi

#echo INFO_ECHO            
    info_echo   
    
    if [ $FILESYSTEM = "exfat" ]; then
        echo "Can't resize exfat filesystems.  Use MS Windows"
        return 1
    fi
    
    
    
    
    # make sure size is OK
    if [ $NEW_SIZE -lt $MIN_SIZE ]; then
        echo_red "ERROR: NewSize can't be smaller than $MIN_SIZE"
        return 1
    fi
    if [ $NEW_SIZE -gt $MAX_SIZE ]; then
        echo_red "ERROR: NewSize can't be bigger than $MAX_SIZE"
        return 1
    fi    
    
    
    
    echo "MODE: $MODE"

    if [ $(ui_yesno "resize" "Resize $PARTITION from $(bytes $FS_SIZE) to $(bytes $NEW_SIZE) ?" ) != "y" ]; then
        echo
        if [ $WAS_MOUNTED ]; then
            echo Remounting $PARTITION...
            sleep 2
            udisksctl mount -b  $PARTITION
            sleep 1
        fi
        return 1
    fi
    echo
    
    
    case $MODE in
    
        grow_fs)
            echo_green GROW filesystem...
            
            echo_green Resize filesystem to "max"       
            media_filesystem_resize "$PARTITION" "max"
            rc=$?
            if (( $rc )); then
                error $LINENO "in filesystem_resize with rc=$rc.  returning"
                return $rc
            fi        
            ;;
        
        grow_part)
            echo_green GROW partition...
            echo_green Resize partition to "$NEW_SIZE"
            media_partition_resize $PARTITION $PART_START $NEW_END 
            rc=$?
            if (( $rc )); then
                error $LINENO "in media_partition_resize with rc=$rc.  returning"
                return $rc
            fi
            ;;
            
        grow)
            echo_green GROW...
            echo_green Resize partition to $PART_START $NEW_END     
            media_partition_resize $PARTITION $PART_START $NEW_END
            rc=$?
            if (( $rc )); then
                error $LINENO "in media_partition_resize with rc=$rc.  returning"
                return $rc
            fi         
            sleep 1
            
            
            echo_green Resize filesystem to "max"       
            media_filesystem_resize "$PARTITION" "max"
            rc=$?
            if (( $rc )); then
                error $LINENO "in filesystem_resize with rc=$rc.  returning"
                return $rc
            fi        
            ;;
        
        shrink)
            echo_green SHRINK...
            echo_green Resize filesystem to "$NEW_SIZE"
            media_filesystem_resize $PARTITION $NEW_SIZE 
            rc=$?
            if (( $rc )); then
                error $LINENO "in media_filesystem_resize with rc=$rc.  returning"
                return $rc
            fi


            echo_green Resize partition to $PART_START $NEW_END
            media_partition_resize $PARTITION $PART_START $NEW_END
            rc=$?
            if (( $rc )); then
                error $LINENO "in media_partition_resize with rc=$rc.  returning"
                return $rc
            fi
            sleep 1
            ;;
    esac
    
    
    # reload Partition info
    info_get

    #show variables
    info_echo
    
    #check values
    ERRORS=0
    info_validate
    
    
  #  echo $WAS_MOUNTED
    if [ $WAS_MOUNTED ]; then
        echo Remounting $PARTITION...
        sleep 2
        udisksctl mount -b  $PARTITION
        sleep 1
    fi
    
    echo_green Resize OK
}


whiptail_calc_wt_size() {
    # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
    # output from tput. However in this case, tput detects neither stdout or 
    # stderr is a tty and so only gives default 80, 24 values

    WT_HEIGHT=20
    WT_WIDTH=80
    WT_HEIGHT_TALL=$(($(tput lines)-10))
    WT_WIDTH_WIDE=$(($(tput cols)-7))
    
    if [[ $WT_WIDTH_WIDE -gt 120 ]]; then
        WT_WIDTH_WIDE=120
    fi

    if [[ -z $WT_WIDTH ]] || [[ $WT_WIDTH -lt 60 ]]; then
        WT_WIDTH=80
    fi
    if [[ $WT_WIDTH -gt 178 ]]; then
        WT_WIDTH=80
    fi

    WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
    WT_MENU_HEIGHT_TALL=$(($WT_HEIGHT_TALL-7))

    WT_MB_HEIGHT=$WT_HEIGHT
    WT_MB_WIDTH=$WT_WIDTH
}


menu() {
       INTERFACE="gui"
    config_var_get_settings
    while true
    do
        whiptail_calc_wt_size
        MENU_CHOICE=$(whiptail --clear --backtitle "$BACKTITLE" --title "MAIN MENU" --ok-button "Select" --cancel-button "Exit" --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "LIST"      "   List media and image files" \
                "INFO"     "  " \
                "MOUNT"    "   Mount media" \
                "UNMOUNT"   "   " \
                "  "        "   " \
                "FirstAid"  "  "\
                "Format"  "   Erase" \
                "SETTINGS"  "   Change settings" \
                "TOOLS"     "   Various tools"\
                 "  "        "   " \
                 "HELP"     "   Help"\
                3>&1 1>&2 2>&3)
 
        whiptail_calc_wt_size        
        case $MENU_CHOICE in
            BACKUP)         media_backup  ;;
            
            RESTORE)        media_restore ;;
            
            LIST)           echo "Getting list of images ready..."
                            ui_msg LIST "$(do_list_info $DEFAULT_PATH)"  ;;
            
            SETTINGS)       menu_settings    ;;
            
            TOOLS)          menu_tools       ;;
            
            HELP)           ui_msg HELP "$(pisafe_help)" ;;
            
            ABOUT)          ui_msg ABOUT "$(pisafe_about)"  ;;     
             
            "  "*)          ;;
            
            * )             return       ;;
        esac
    done
    
}


CMD=$1  
TARGET=$(device_fullname $2)
SPECS=$3


INSTALL=$(env_installer)


case $CMD in
    -v)
        echo $VER
        exit
        ;;
        
    -h|help)
        disk_utility_help
        exit
        ;;
        
    list)
        if  [[ -z $TARGET ]]; then
            run_command "lsblk -o name,size,type,mountpoint,fstype,fsuse%" $LINENO
            #run_command "sudo parted $(findmnt -no source /)  print all" $LINENO
            echo
        else
            run_command "sudo parted $TARGET print free" $LINENO
        fi    
        ;;        

    info*) 
        if [[ -z $TARGET ]]; then
            echo "Usage: diskutil info[rmation] device"
            exit
        fi
        
        #echo DiskInfo:
        echo Partition table: $(media_disk_partition_table $TARGET)
    
        case $(lsblk -n -d -o type $TARGET) in
            disk|part) 
                #run_command "lsblk $TARGET -o name,path,mountpoint,fstype,pttype,ptuuid,partuuid,size,label,vendor,model" $LINENO
                run_command "sudo parted -s $TARGET print free | grep -v Partition" $LINENO
                run_command "lsblk -f $TARGET" $LINENO
                ;;
            
            *)
                echo Error
                ;;
        esac
        ;;

    listFilesystems)
            echo "Formattable file systems"
            echo
            echo "fat16, fat32, exfat, ntfs, ext2, ext3, ext4 "
            
            exit
            ;;

    umount|unmount)         media_filesystem_unmount $TARGET  ;;  
    umountDisk|unmountDisk) media_disk_unmount $TARGET ;;
    eject)                  media_disk_eject $TARGET;;
    mount)              media_filesystem_mount $TARGET  ;;      
    mountDisk)          media_disk_mount $TARGET;;

    rename|renameFilesystem)    media_filesystem_rename $2 $3 ;;
    
    verify)       media_filesystem_check $TARGET  ;;
    repair)       media_filesystem_check $TARGET;;
    verifyDisk)         media_disk_verify $TARGET ;; 
    repairDisk)         media_disk_repair $TARGET ;; 
    
    eraseDisk)          media_disk_format $2 "$3" $4 $5;;
    erasePartition)     media_partition_format $2 $3 $4 $5;;
    reformat)           media_partition_reformat $2;;
    
    zeroDisk)           media_disk_wipe $TARGET zero ;;    #shred or dd or 
    randomDisk)         media_disk_wipe $TARGET random  ;;
    secureErase)        media_disk_wipe $TARGET shred  ;;
    
    partitionDisk)          media_disk_partition $2 $3 $4 $5 $6;;
    
    createPartitionTable)   media_disk_createpartitiontable $2 $3 $4  ;;
    addPartition)           media_disk_addpartition $2 $3 $4 $5 $6 ;;
    delPartition)           media_disk_delpartition $2 $3 $4 $5 $6 ;;
    resizeFilesystem)       media_filesystem_resize $2 $3 $4 ;;
    
    print2) 
        info_get $2
        info_echo
        ;;
            
    clone)
        SOURCE=$1
        TARGET=$2
        media_clone $SOURCE $TARGET 
        ;;
        
    test)           media_test $TARGET ;;
        
    settings)       nano $SETTINGS ;;
    
    log)            nano $LOG_FILE ;;    
     
    menu)           menu ;; 
                
    *)
        disk_utility_help
        #error $LINENO "Command '$CMD' not recognized"
        #exit
        ;;
            
esac
